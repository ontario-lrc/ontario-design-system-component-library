/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from '@stencil/core/internal';
import { ExpandCollapseButtonDetails } from './components/ontario-accordion/expandCollapseButtonDetails.interface';
import { Accordion } from './components/ontario-accordion/accordion.interface';
import { Language } from './utils/common/language-types';
import {
	HeadingContentType,
	HeadingLevelOptions,
	HighlightColourOptions,
} from './utils/components/callout-aside/callout-aside.interface';
import { ButtonType, HtmlType } from './components/ontario-button/ontario-button.types';
import {
	CardType,
	HeaderType,
	HorizontalImagePositionType,
	HorizontalImageSizeType,
} from './components/ontario-card/ontario-card-types';
import { CardsPerRow } from './components/ontario-card-collection/ontario-collection-card-types';
import { Caption } from './utils/common/input-caption/caption.interface';
import { Hint, HintContentType } from './utils/common/common.interface';
import { HintExpander } from './components/ontario-hint-expander/hint-expander.interface';
import { CheckboxOption } from './components/ontario-checkbox/checkbox-option.interface';
import {
	InputFocusBlurEvent,
	InputInputEvent,
	InputInteractionEvent,
	RadioAndCheckboxChangeEvent,
} from './utils/events/event-handler.interface';
import {
	DateInputFieldType,
	DateInputPlaceholder,
	DateValidatorReturnType,
} from './components/ontario-date-input/ontario-date-input-interface';
import { DropdownOption } from './components/ontario-dropdown-list/dropdown-option.interface';
import { CaptionType } from './utils/common/input-caption/input-caption.types';
import {
	FooterLinks,
	OntarioFooterType,
	ThreeColumnOptions,
	TwoColumnOptions,
} from './components/ontario-footer/ontario-footer-interface';
import { FooterSocialLinksProps } from './components/ontario-footer/components';
import {
	ApplicationHeaderInfo,
	LanguageToggleOptions,
	MenuItem,
	OntarioHeaderType,
} from './components/ontario-header/ontario-header.interface';
import { IconColour, IconSize } from './components/ontario-icon/icon.types';
import { HeaderLanguageToggleEventDetails } from './utils/events/common-events.interface';
import { PageAlertType } from './components/ontario-page-alert/ontario-page-alert.interface';
import { RadioOption } from './components/ontario-radio-buttons/radio-option.interface';
import { TableColumnOptions, TableRowOptions } from './components/ontario-table/table.interface';
export { ExpandCollapseButtonDetails } from './components/ontario-accordion/expandCollapseButtonDetails.interface';
export { Accordion } from './components/ontario-accordion/accordion.interface';
export { Language } from './utils/common/language-types';
export {
	HeadingContentType,
	HeadingLevelOptions,
	HighlightColourOptions,
} from './utils/components/callout-aside/callout-aside.interface';
export { ButtonType, HtmlType } from './components/ontario-button/ontario-button.types';
export {
	CardType,
	HeaderType,
	HorizontalImagePositionType,
	HorizontalImageSizeType,
} from './components/ontario-card/ontario-card-types';
export { CardsPerRow } from './components/ontario-card-collection/ontario-collection-card-types';
export { Caption } from './utils/common/input-caption/caption.interface';
export { Hint, HintContentType } from './utils/common/common.interface';
export { HintExpander } from './components/ontario-hint-expander/hint-expander.interface';
export { CheckboxOption } from './components/ontario-checkbox/checkbox-option.interface';
export {
	InputFocusBlurEvent,
	InputInputEvent,
	InputInteractionEvent,
	RadioAndCheckboxChangeEvent,
} from './utils/events/event-handler.interface';
export {
	DateInputFieldType,
	DateInputPlaceholder,
	DateValidatorReturnType,
} from './components/ontario-date-input/ontario-date-input-interface';
export { DropdownOption } from './components/ontario-dropdown-list/dropdown-option.interface';
export { CaptionType } from './utils/common/input-caption/input-caption.types';
export {
	FooterLinks,
	OntarioFooterType,
	ThreeColumnOptions,
	TwoColumnOptions,
} from './components/ontario-footer/ontario-footer-interface';
export { FooterSocialLinksProps } from './components/ontario-footer/components';
export {
	ApplicationHeaderInfo,
	LanguageToggleOptions,
	MenuItem,
	OntarioHeaderType,
} from './components/ontario-header/ontario-header.interface';
export { IconColour, IconSize } from './components/ontario-icon/icon.types';
export { HeaderLanguageToggleEventDetails } from './utils/events/common-events.interface';
export { PageAlertType } from './components/ontario-page-alert/ontario-page-alert.interface';
export { RadioOption } from './components/ontario-radio-buttons/radio-option.interface';
export { TableColumnOptions, TableRowOptions } from './components/ontario-table/table.interface';
export namespace Components {
	interface OntarioAccordion {
		/**
		 * Used to include individual accordion data for the accordion component. This is passed in as an array of objects with key-value pairs.  The `content` is expecting a string, that can either be written as HTML or a just a plain string, depending on the accordionContentType.
		 * @example 	<ontario-accordion 	name="My Accordion" 	accordion-data='[ 		{"label": "Accordion 1", "content": "This is a string"}, 		{"label": "Accordion 2", "accordionContentType": "html", "content": "<ul><li>List A</li><li>List B</li><li>List C</li></ul>"} 	]' ></ontario-accordion>
		 */
		accordionData: string | Accordion[];
		/**
		 * Custom Expand/Collapse button text.
		 * @example  <ontario-accordion 	name="My Accordion" 	expand-collapse-button='{ 		"expandAllSectionsLabel": "Expand All", 		"collapseAllSectionsLabel": "Collapse All" 	}' 	accordion-data='[ 		{"label": "Accordion 1", "content": ["Item 1", "Item 2", "Item 3"]}, 		{"label": "Accordion 2", "content": ["Item A", "Item B", "Item C"]} 	]' ></ontario-accordion>
		 */
		expandCollapseButton?: string | ExpandCollapseButtonDetails;
		/**
		 * Used to show whether the accordion is opened or closed.
		 */
		isOpen: boolean;
		/**
		 * The language of the component. This is used for translations, and is by default set through event listeners checking for a language property from the header. If none are passed, it will default to English.
		 */
		language?: Language;
		/**
		 * The name of the accordion component.  This is not optional.
		 */
		name: string;
	}
	interface OntarioAside {
		/**
		 * Optional text to be displayed as the content for the aside component. If a string is passed, it will automatically be nested in a paragraph tag.  HTML content can also be passed as the child/children of the aside component if additional/different elements for the content are needed.
		 * @example <ontario-aside headingType='h3' headingContent='This is the aside heading'><p>This is the first sentence of the aside content.</p><p>This is the second sentence of the aside content.</p></ontario-aside>
		 */
		content?: string;
		/**
		 * Text or HTML to be displayed as the heading of the aside. If the heading content should be displayed as HTML, the `headingContentType` needs to be set to `html`.
		 */
		headingContent: string;
		/**
		 * The type of the heading content. If no prop is passed, it will default to string.
		 */
		headingContentType: HeadingContentType;
		/**
		 * The heading level of the aside heading.
		 */
		headingType: HeadingLevelOptions;
		/**
		 * Optional prop to choose the border colour of the aside. If none is passed, the default colour will be teal.
		 */
		highlightColour?: HighlightColourOptions;
	}
	interface OntarioBackToTop {
		/**
		 * The language of the component. This is used for translations, and is by default set through event listeners checking for a language property from the header. If no language prop is passed, it will default to English.
		 */
		language?: Language;
	}
	interface OntarioBlockquote {
		/**
		 * Optional text to be displayed as the attribution (the author) of the quote.
		 */
		attribution?: string;
		/**
		 * Optional text to be displayed for additional information about the attribution/author.
		 */
		byline?: string;
		/**
		 * Text to be displayed as the quote.  Note that wrapping the quotes in quotations is not needed - this is handled through the component styles
		 */
		quote: string;
	}
	interface OntarioButton {
		/**
		 * Provides more context as to what the button interaction is doing. This should only be used for accessibility purposes, if the button interaction requires more description than what the text provides.   This is optional.
		 * @example <ontario-button aria-label-text="Click button to open map">Open</ontario button>
		 */
		ariaLabelText?: string;
		/**
		 * The unique identifier of the button. This is optional - if no ID is passed, one will be generated.
		 */
		elementId?: string;
		/**
		 * The native HTML button type the button should use.  If no htmlType is passed, it will default to 'button'.
		 */
		htmlType: HtmlType;
		/**
		 * Text to be displayed within the button. This will override the text provided through the host element textContent.
		 * @example <ontario-button label="Label Text">Text</ontario-button>  The resulting button will have the label `"Label Text"`.
		 */
		label?: string;
		/**
		 * The type of button to render.  If no type is passed, it will default to 'secondary'.
		 */
		type: ButtonType;
	}
	interface OntarioCallout {
		/**
		 * Optional text to be displayed as the content for the callout component. If a string is passed, it will automatically be nested in a paragraph tag.  HTML content can also be passed as the child/children of the callout component if additional/different elements for the content are needed.
		 * @example <ontario-callout headingType='h3' headingContent='This is the callout heading'><p>This is the first sentence of the callout content.</p><p>This is the second sentence of the callout content.</p></ontario-callout>
		 */
		content?: string;
		/**
		 * Text or HTML to be displayed as the heading of the callout. If the heading content should be displayed as HTML, the `headingContentType` needs to be set to `html`.
		 */
		headingContent: string;
		/**
		 * The type of the heading content. If no prop is passed, it will default to `string`.
		 */
		headingContentType: HeadingContentType;
		/**
		 * The heading level of the callout heading.
		 */
		headingType: HeadingLevelOptions;
		/**
		 * Optional prop to choose the border colour of the callout. If none is passed, the default colour will be teal.
		 */
		highlightColour?: HighlightColourOptions;
	}
	interface OntarioCard {
		/**
		 * Provides more context as to what the card interaction is doing. This should only be used for accessibility purposes, if the card interaction requires more * * description than what the text provides.  This is optional.
		 */
		ariaLabelText?: string;
		/**
		 * Action link for when the card is clicked.  This is optional.
		 */
		cardLink?: string;
		/**
		 * The type of card to render.  If no type is passed, it will default to 'basic'.
		 */
		cardType: CardType;
		/**
		 * Text to be displayed within the card description container.  This is optional.
		 */
		description?: string;
		/**
		 * The type of header to render.  If no type is passed, it will default to 'default'.
		 */
		headerType: HeaderType;
		/**
		 * The position of the image when the card-type is set to 'horizontal'.  This prop is only necessry when the card-type is set to 'horizontal'.
		 * @example 	<ontario-card 	card-type="horizontal" 	label="Card Title 1" 	image="https://picsum.photos/200/300" 	horizontal-image-position-type="left" 	horizontal-image-size-type="one-fourth"   description="Lorem Ipsum Lorem Ipsum Lorem Ipsum Lorem Ipsum Lorem Ipsum Lorem Ipsum Lorem Ipsum Lorem Ipsum" > </ontario-card>
		 */
		horizontalImagePositionType?: HorizontalImagePositionType;
		/**
		 * The size of the image when the card-type is set to 'horizontal'.  This prop is only necessry when the card-type is set to 'horizontal'.
		 * @example 	<ontario-card 	card-type="horizontal" 	label="Card Title 1" 	image="https://picsum.photos/200/300" 	horizontal-image-position-type="left" 	horizontal-image-size-type="one-fourth"   description="Lorem Ipsum Lorem Ipsum Lorem Ipsum Lorem Ipsum Lorem Ipsum Lorem Ipsum Lorem Ipsum Lorem Ipsum" > </ontario-card>
		 */
		horizontalImageSizeType?: HorizontalImageSizeType;
		/**
		 * Image to be displayed within the card image container.  This is optional.
		 */
		image?: string;
		/**
		 * Text to be displayed within the header.
		 * @example <ontario-card 	header-type="dark" 	card-type="horizontal" 	label="Card Title 1" 	description="Lorem Ipsum Lorem Ipsum Lorem Ipsum Lorem Ipsum Lorem Ipsum Lorem Ipsum Lorem Ipsum Lorem Ipsum" >
		 */
		label: string;
	}
	interface OntarioCardCollection {
		/**
		 * The number of cards to display per row.  If no number is passed, it will default to 3.
		 */
		cardsPerRow: CardsPerRow;
	}
	interface OntarioCheckboxes {
		/**
		 * The text to display for the checkbox legend.
		 * @example <ontario-checkboxes   caption='{     "captionText": "Checkbox legend",     "captionType": "heading",   }   ...> </ontario-checkboxes>
		 */
		caption: Caption | string;
		/**
		 * Used to add a custom function to the checkbox onBlur event.
		 */
		customOnBlur?: (event: globalThis.Event) => void;
		/**
		 * Used to add a custom function to the checkbox onChange event.
		 */
		customOnChange?: (event: globalThis.Event) => void;
		/**
		 * Used to add a custom function to the checkbox onFocus event.
		 */
		customOnFocus?: (event: globalThis.Event) => void;
		/**
		 * Used to include the ontario-hint-expander component for the checkbox group. This is passed in as an object with key-value pairs.  This is optional.
		 * @example <ontario-checkboxes   caption='{     "captionText": "Checkbox legend",     "captionType": "heading",   }   name='ontario-checkboxes'   options='[ 	{ 		"value": "checkbox-option-1", 		"label": "Checkbox option 1 label", 		"elementId": "checkbox-1" 	}   }]'   hint-expander='{    "hint": "Hint expander for the checkbox group",    "content": "Example hint expander content for the checkbox group"   }'   required="true" > </ontario-checkboxes>
		 */
		hintExpander?: HintExpander | string;
		/**
		 * Used to include the ontario-hint-text component for the checkbox group. This is optional.
		 */
		hintText?: string | Hint;
		/**
		 * The language of the component. This is used for translations, and is by default set through event listeners checking for a language property from the header. If no language is passed, it will default to English.
		 */
		language?: Language;
		/**
		 * The name for the checkboxes. The name value is used to reference form data after a form is submitted.
		 */
		name: string;
		/**
		 * The options for the checkbox group.  Each property will be passed in through an object in the options array. This can either be passed in as an object directly (if using react), or as a string in HTML. If there are multiple checkboxes in a fieldset, each checkbox will be displayed as an option.  In the example below, the options are being passed in as a string and there are two checkboxes to be displayed in the fieldset.
		 * @example <ontario-checkboxes   caption='{ 	"captionText": "Checkbox legend", 	"captionType": "heading",   }   name="ontario-checkboxes",   hint-text="Hint text for the checkbox group."   options='[ 	{ 		"value": "checkbox-option-1", 		"label": "Checkbox option 1 label" 		"elementId": "checkbox-1"     },     {        "value": "checkbox-option-2",        "label": "Checkbox option 2 label", 		  "elementId": "checkbox-2",       "hintExpander": { 			"hint": "Hint expander for checkbox option 2",              "content": "Example hint expander content for checkbox option 2"        }      }   ]'   required="true" > </ontario-checkboxes>
		 */
		options: CheckboxOption[] | string;
		/**
		 * This is used to determine whether the checkbox is required or not. This prop also gets passed to the InputCaption utility to display either an optional or required flag in the label. If no prop is set, it will default to false (optional).
		 */
		required?: boolean;
	}
	interface OntarioCriticalAlert {
		/**
		 * Content for critical alert message. It can be either string or HTML content. The content is already wrapped in a paragraph tag, so if using HTML content, the paragraph tag can be ommitted.
		 * @example <ontario-critical-alert content="COVID-19 State of emergency extended until May 12, 2020."></ontario-critical-alert>  or  <ontario-critical-alert>  <a href="#">COVID-19 State of emergency</a> extended until May 12, 2020. </ontario-critical-alert>
		 */
		content: string | HTMLElement;
	}
	interface OntarioDateInput {
		/**
		 * The text to display as the input label
		 * @example <ontario-date-input   caption='{     "captionText": "Exact Date",     "captionType": "heading",   }   required="true"   ...> </ontario-date-input>
		 */
		caption: Caption | string;
		/**
		 * An array value used to display date options. For example, only the day and month fields can be displayed by specifying the dateOptions as `["day", "month"]`, etc.  This is optional. If no prop for `dateOptions` is passed, it will default to `["day", "month", "year"]`.
		 */
		dateOptions?: string | Array<DateInputFieldType>;
		/**
		 * A function used to override internal date validation logic, which takes three arguments (i.e day, month and year) and returns an object of type `DateValidatorReturnType`  This is optional. If no prop for `dateValidator` is passed, it will default to internal validation function to validate the date input.
		 */
		dateValidator?: (day: string, month: string, year: string) => DateValidatorReturnType;
		/**
		 * The unique identifier of the input. This is optional - if no ID is passed, one will be generated.
		 */
		elementId?: string;
		/**
		 * Used to include the ontario-hint-text component for the date input group.  This is optional.
		 */
		hintText?: string;
		/**
		 * The language of the component. This is used for translations, and is by default set through event listeners checking for a language property from the header. If none are passed, it will default to English.
		 */
		language?: Language;
		/**
		 * A number value indicating maximum value allowed for year input field of the date component.  This is optional. If no prop is passed, it will default to `9999`.
		 */
		maxYear?: number;
		/**
		 * A number value indicating minimum value allowed for year input field of the date component.  This is optional. If no prop is passed, it will default to `999`.
		 */
		minYear?: number;
		/**
		 * An object value used to set the placeholder text for the day, month and year input fields. Any combination of the three input fields (i.e day, month, year) of the date component can be overridden.  This is optional. If no prop is passed, it will not display any placeholder text.
		 */
		placeholder?: DateInputPlaceholder | string;
		/**
		 * A boolean value to determine whether or not the date input is required.  This is optional. If no prop is passed, it will default to `false`.
		 */
		required?: boolean;
	}
	interface OntarioDropdownList {
		/**
		 * The text to display for the dropdown list label.
		 * @example <ontario-dropdown-list   name="ontario-dropdown-list"   caption='{     "captionText": "Label",     "captionType": "heading",   }'   ...> </ontario-dropdown-list>
		 */
		caption: Caption | string;
		/**
		 * Used to add a custom function to the dropdown onBlur event.
		 */
		customOnBlur?: (event: globalThis.Event) => void;
		/**
		 * Used to add a custom function to the dropdown onChange event.
		 */
		customOnChange?: (event: globalThis.Event) => void;
		/**
		 * Used to add a custom function to the dropdown onFocus event.
		 */
		customOnFocus?: (event: globalThis.Event) => void;
		/**
		 * The ID for the dropdown list. If no ID is provided, one will be generated.
		 */
		elementId?: string;
		/**
		 * Used to include the ontario-hint-expander component for the dropdown list component. This is passed in as an object with key-value pairs.  This is optional.
		 * @example <ontario-dropdown-list   caption='{     "caption": "What province do you live in?",     "captionType": "heading",   }   name="ontario-dropdown-list"   options='[     {       "value": "dropdown-option-1",       "label": "Option 1",       "selected": "true"     },     {       "value": "dropdown-option-2",       "label": "Option 2"     },     {       "value": "dropdown-option-3",       "label": "Option 3"     }   ]'   hint-expander='{    "hint": "Hint expander for the dropdown list",    "content": "Example hint expander content for the dropdown list."   }' > </ontario-dropdown-list>
		 */
		hintExpander?: HintExpander | string;
		/**
		 * Used to include the ontario-hint-text component for the dropdown list. This is optional.
		 */
		hintText?: string | Hint;
		/**
		 * This prop is used to determine whether or not the initial option displayed is empty. If set to `true`, it will render the default “select” text. If set to a string, it will render the string value.
		 * @example <ontario-dropdown-list is-empty-start-option="true"></ontario-dropdown-list>  or  <ontario-dropdown-list is-empty-start-option="Please select"></ontario-dropdown-list>
		 */
		isEmptyStartOption?: boolean | string;
		/**
		 * The language of the component. This is used for translations, and is by default set through event listeners checking for a language property from the header. If no language is passed, it will default to English.
		 */
		language?: Language;
		/**
		 * The name for the dropdown list. The name value is used to reference form data after a form is submitted.
		 */
		name: string;
		/**
		 * The options for dropdown list.  Each option will be passed in through an object in the options array. This can either be passed in as an object directly (if using react), or as a string in HTML.  In the example below, the options are being passed in as a string and there are three dropdown options displayed.
		 * @example <ontario-dropdown-list   caption='{     "captionText": "Label",     "captionType": "heading",   }'   name="ontario-dropdown-list"   options='[     {       "value": "dropdown-option-1",       "label": "Option 1",       "selected": "true"     },     {       "value": "dropdown-option-2",       "label": "Option 2"     },     {       "value": "dropdown-option-3",       "label": "Option 3"     }   ]' > </ontario-dropdown-list>
		 */
		options: string | DropdownOption[];
		/**
		 * This is used to determine whether the dropdown list is required or not. This prop also gets passed to the InputCaption utility to display either an optional or required flag in the label. If no prop is set, it will default to false (optional).
		 */
		required?: boolean;
	}
	interface OntarioFieldset {
		/**
		 * The text value used for the legend of the fieldset.
		 */
		legend: string;
		/**
		 * The size of the fieldset legend. If no prop is passed, it will be `default`.
		 */
		legendSize: CaptionType;
	}
	interface OntarioFooter {
		/**
		 * The base path to an assets folder containing the Design System assets
		 */
		assetBasePath: string;
		/**
		 * A prop that stores the required links for all footers. Available options are 'accessibilityLink', 'privacyLink', 'contactLink' and 'printerLink'
		 */
		footerLinks: FooterLinks | string;
		/**
		 * The language of the component. This is used for translations, and is by default set through event listeners checking for a language property from the header. If no language is passed, it will default to English.
		 */
		language: Language;
		/**
		 * Social media links to render in the footer. Available options are 'facebook', 'twitter', 'instagram' and 'youtube'
		 */
		socialLinks: FooterSocialLinksProps | string;
		/**
		 * Stores the titles and content for the expanded three column footer.
		 */
		threeColumnOptions?: ThreeColumnOptions | string;
		/**
		 * Top margin for the footer. By default, this prop is set to `true`, which adds a margin top value of `5rem`. If set to `false`, the top margin value will be set to zero.
		 */
		topMargin: boolean;
		/**
		 * Stores the titles and content for the expanded two column footer.
		 */
		twoColumnOptions?: TwoColumnOptions | string;
		/**
		 * The type of footer to be rendered. If no prop is provided, it will default to the 'default' type.
		 */
		type: OntarioFooterType;
	}
	interface OntarioHeader {
		/**
		 * Information pertaining to the application header. This is only necessary for the 'application' header type.  This includes the application name, URL and optional props for the number of links in the subheader for desktop, tablet, and mobile views.
		 * @example  <ontario-header    type="application"    application-header-info='{      "title": "Application name",      "href": "/application-homepage",      "maxSubheaderDesktopLinks": "3",      "maxSubheaderTabletLinks": "2",      "maxSubheaderMobileLinks": "1"    }'>  </ontario-header>
		 */
		applicationHeaderInfo: ApplicationHeaderInfo | string;
		/**
		 * The base path to an assets folder containing the Design System assets
		 */
		assetBasePath: string;
		/**
		 * A custom function to pass to the language toggle button.
		 */
		customLanguageToggle?: (event: globalThis.Event) => void;
		/**
		 * Option to disable fetching of the dynamic menu from the Ontario Header API
		 * @example 	<ontario-header 			type="ontario" 			disable-dynamic-menu="false" 		menu-items='[{ 			"title": "Hint", 			"href": "/ontario-hint" 			"linkIsActive": "false" 		},{ 			"title": "Hint", 			"href": "/ontario-hint" 			"linkIsActive": "false" 		},{ 			"title": "Hint", 			"href": "/ontario-hint" 			"linkIsActive": "false" 		},{ 			"title": "Hint", 			"href": "/ontario-hint" 			"linkIsActive": "false" 		}]'> </ontario-header>
		 */
		disableDynamicMenu: boolean;
		/**
		 * The language of the component. This is used for translations, and is by default set through event listeners checking for a language property from the header. If none is passed, it will default to English.
		 */
		language?: Language;
		/**
		 * Information pertaining to the language toggle links.
		 * @example <ontario-header 	language-toggle-options='{    "englishLink": "/en",    "frenchLink": "/fr"  }'  ... > </ontario-header>
		 */
		languageToggleOptions?: LanguageToggleOptions | string;
		/**
		 * The items that will go inside the menu.
		 */
		menuItems: MenuItem[] | string;
		/**
		 * The type of header.
		 */
		type?: OntarioHeaderType;
	}
	interface OntarioHintExpander {
		/**
		 * Content to display as the hint, once the expander is toggled open. Please note that any content that is passed into this prop will only be displayed as a string. If you would like to add HTML content, supply child content to the component.
		 * @example <ontario-hint-expander hint="This is the hint"   <img src="https://www.jquery-az.com/html/images/banana.jpg" title="Title of image" alt="alt text here"/>   <p> Here is the content beside the image </p> </ontario-hint-expander>
		 */
		content: string;
		/**
		 * Used to used to establish a relationship between hint text content and elements using aria-describedby. This is optional - if no ID is passed, one will be generated.
		 */
		elementId?: string;
		/**
		 * Text to display as the hint expander question/statement
		 */
		hint: string;
		/**
		 * The content type of the hint. If no prop is passed, it will default to a string. If the hint requires multiple lines or HTML, the `hintContentType` prop should be set to `html`.
		 */
		hintContentType?: HintContentType;
	}
	interface OntarioHintText {
		/**
		 * The unique identifier of the element. This is optional - if no ID is passed, one will be generated.
		 */
		elementId?: string;
		/**
		 * This method returns the ontario-hint-text id. It is used to make sure the hint text and `aria-describedby` value of other form components match when the internal hint text props are used.
		 * @returns Promise<string | undefined>
		 */
		getHintTextId: () => Promise<string | undefined>;
		/**
		 * Text to display as the hint text statement.  Setting the hint can be done using the host element textContent or through setting this property.  This property will take precedence.
		 * @example <ontario-hint-text hint="Override Hint Text">Hint Text</ontario-button>  The resulting hint text will display `"Override Hint Text"`.
		 */
		hint: string;
		/**
		 * The content type of the hint. If no prop is passed, it will default to a string. If the hint requires multiple lines or HTML, the `hintContentType` prop should be set to `html`.
		 */
		hintContentType?: HintContentType;
	}
	interface OntarioIconAccessibility {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconAccount {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconAdd {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconAddAlt {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconAlertError {
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconAlertInformation {
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconAlertSuccess {
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconAlertWarning {
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconArrowUp {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconAttach {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconBookmarkOff {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconBookmarkOn {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconCalendar {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconCamera {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconChevronDown {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconChevronLeft {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconChevronRight {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconChevronUp {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconClock {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconClose {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconCloseHeader {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconCloud {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconCollapse {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconCreditCard {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconCriticalAlertWarning {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconDelete {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconDocument {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconDownload {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconDropdownArrow {
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconEdit {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconEmail {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconExpand {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconExport {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconFacebook {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconFacebookAlt {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconFavouriteOff {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconFavouriteOn {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconFilter {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconFlickr {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconGrid {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconHelp {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconInstagram {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconInteracEn {
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconInteracEnAlt {
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconInteracFr {
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconInteracFrAlt {
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconLinkedin {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconLinkedinAlt {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconList {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconLiveChat {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconLocationOff {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconLocationOn {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconLockOff {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconLockOn {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconMap {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconMastercard {
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconMastercardAlt {
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconMediaFastForward {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconMediaFastRewind {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconMediaPause {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconMediaPlay {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconMediaStop {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconMenu {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconMenuHeader {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconMicrophoneOff {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconMicrophoneOn {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconMoreVertical {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconNewWindow {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconNext {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconNotification {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconPasswordHide {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconPasswordShow {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconPhone {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconPhoto {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconPinLocationOff {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconPinLocationOn {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconPrevious {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconPrint {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconRemove {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconRemoveAlt {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconReplay {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconRssFeed {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconSave {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconSearch {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconSearchWhite {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconSentiment1 {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconSentiment2 {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconSentiment3 {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconSentiment4 {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconSentiment5 {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconSettings {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconShare {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconSort {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconTag {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconTextMessage {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconTimer {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconTransportBicycle {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconTransportBus {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconTransportCar {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconTransportWalk {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconTty {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconTwitter {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconTwitterAlt {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconUpload {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconVideo {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconVisa {
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconVoteDislike {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconVoteLike {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconVpnKey {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconWheelchair {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconWifi {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioIconYoutube {
		/**
		 * Set the icon's colour.
		 */
		colour: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth: IconSize;
	}
	interface OntarioInput {
		/**
		 * The text to display as the input label
		 * @example <ontario-input   caption='{     "captionText": "Address",     "captionType": "heading",   }   required="true"   ...> </ontario-input>
		 */
		caption: Caption | string;
		/**
		 * Used to add a custom function to the input onBlur event.
		 */
		customOnBlur?: (event: globalThis.Event) => void;
		/**
		 * Used to add a custom function to the input onChange event.
		 */
		customOnChange?: (event: globalThis.Event) => void;
		/**
		 * Used to add a custom function to the input onFocus event.
		 */
		customOnFocus?: (event: globalThis.Event) => void;
		/**
		 * Used to add a custom function to the input onInput event.
		 */
		customOnInput?: (event: globalThis.Event) => void;
		/**
		 * The unique identifier of the input. This is optional - if no ID is passed, one will be generated.
		 */
		elementId?: string;
		/**
		 * Enable live validation on the input.  Custom live validation can be performed using an `inputValidator` validation function.  It will also validate the `required` state if no errors are returned from the `inputValidator`.  Please set a `requiredValidationMessage` to report concisely to the end user what they are required to set.
		 */
		enableLiveValidation: boolean;
		/**
		 * Set this to display an
		 */
		errorMessage?: string;
		/**
		 * Used to include the ontario-hint-expander component for the input component. This is passed in as an object with key-value pairs.  This is optional.
		 * @example <ontario-input   caption='{     "caption": "Address",     "captionType": "heading",   }   hint-expander='{    "hint": "Hint expander",    "content": "This is the content"   }'   required="true" > </ontario-input>
		 */
		hintExpander?: HintExpander | string;
		/**
		 * Used to include the ontario-hint-text component for the input. This is optional.
		 */
		hintText?: string | Hint;
		/**
		 * Validate the validity of the input value `onBlur`.  This `async` function should return a result to trigger an error message.  Returning `undefined` or `null` will clear it.
		 */
		inputValidator?: (value?: string) => Promise<{ errorMessage?: string } | null | undefined>;
		/**
		 * The width of the input field. If no value is assigned, it will present as the `default` input width.
		 */
		inputWidth:
			| '2-char-width'
			| '3-char-width'
			| '4-char-width'
			| '5-char-width'
			| '7-char-width'
			| '10-char-width'
			| '20-char-width'
			| 'default';
		/**
		 * The language of the component. This is used for translations, and is by default set through event listeners checking for a language property from the header. If no language is passed, it will default to English.
		 */
		language?: Language;
		/**
		 * The name assigned to the input. The name value is used to reference form data after a form is submitted.
		 */
		name: string;
		/**
		 * This is used to determine whether the input is required or not. This prop also gets passed to the InputCaption utility to display either an optional or required flag in the label. If no prop is set, it will default to false (optional).  _Please add a validation messaging using `requiredValidationMessage` if setting this property._
		 * @example <ontario-input 	id="address-line-1" 	caption="Address line 1" 	required 	required-validation-message="Please enter an address, including street number and street name" 	name="address-line-1" 	hint-text="Street and number or P.O. box." ></ontario-input>
		 */
		required?: boolean;
		/**
		 * Custom error message to display if a required field is not filled out.  _Please add a custom message when setting an input as required_.
		 */
		requiredValidationMessage: string;
		/**
		 * The input type value.  If no `type` is provided, it will default to 'text'.
		 */
		type: 'text' | 'tel' | 'email' | 'password';
		/**
		 * The input content value.  This is optional.
		 */
		value?: string;
	}
	interface OntarioLanguageToggle {
		/**
		 * A custom function to pass to the language toggle button.  This is optional.
		 */
		customLanguageToggle?: (event: globalThis.Event) => void;
		language: Language | string;
		/**
		 * The size of the language toggle button.  If no prop is passed, it will be set to the `default` size.
		 */
		size?: 'default' | 'small';
		/**
		 * The URL to change to when the language toggle button is clicked.  This is optional.
		 */
		url?: string;
	}
	interface OntarioLoadingIndicator {
		/**
		 * A boolean value to determine whether the loading indicator overlay covers the full page or not. By default, this is set to `true`.  If set to `false`, the loading indicator overlay will be positioned absolutely relative to its container. Note that this will only work if the containing element has a style rule specifying it to be positioned relatively.
		 */
		fullScreenOverlay?: boolean;
		/**
		 * A boolean value to determine whether or not the loading indicator is loading (i.e: is visible) or not.
		 */
		isLoading: boolean;
		/**
		 * The language of the component. This is used for translations, and is by default set through event listeners checking for a language property from the header. If no language is passed, it will default to English.
		 */
		language?: Language;
		/**
		 * The message that tells the user what is happening or why the user is waiting. If no message prop is passed, it will default to "Loading". Translations for this default message are included.  This is optional.
		 */
		message?: string;
		/**
		 * The type of loading indicator to render.
		 */
		type: 'small' | 'large';
	}
	interface OntarioPageAlert {
		/**
		 * The main content for the page alert. This can be rendered as either string or HTML content.
		 * @example <ontario-page-alert content="Please look out for an email confirmation with your receipt and order number."> </ontario-page-alert>  or  <ontario-page-alert>  <p>This is a sample page alert component using slots. <a href="#">Learn more</a>.</p> </ontario-page-alert>
		 */
		content: string;
		/**
		 * The heading for the page alert.
		 * @example <ontario-page-alert heading="Licence plates"> </ontario-page-alert>
		 */
		heading: string;
		/**
		 * The type of page alert to render. If no value is provided, the `informational` type alert would be rendered.  There are four possible values for page alert: `informational`, `warning`, `success` or `error`.
		 * @example <ontario-page-alert type="error"> </ontario-page-alert>
		 */
		type: PageAlertType;
	}
	interface OntarioRadioButtons {
		/**
		 * The text to display for the radio button legend.
		 * @example <ontario-radio-buttons   caption='{     "captionText": "Radio legend",     "captionType": "heading",    }'   required="true"   ...> </ontario-radio-buttons>
		 */
		caption: Caption | string;
		/**
		 * Used to add a custom function to the radio input onBlur event.
		 */
		customOnBlur?: (event: globalThis.Event) => void;
		/**
		 * Used to add a custom function to the radio input onChange event.
		 */
		customOnChange?: (event: globalThis.Event) => void;
		/**
		 * Used to add a custom function to the radio input onFocus event.
		 */
		customOnFocus?: (event: globalThis.Event) => void;
		/**
		 * Used to include the ontario-hint-expander component for the radio button group. This is passed in as an object with key-value pairs.  This is optional.
		 * @example <ontario-radio-buttons   caption='{     "captionText": "Radio legend",     "captionType": "heading",   }' 	 name="radios"   options='[ 	   {        "value": "radio-option-1", 		  "elementId": "radio-1",        "label": "Radio option 1 label",        "hintExpander": { 		  "hint": "Hint expander for radio option 1", 		      "content": "Example hint expander content for radio option 1." 	  }     }   ]'   hint-expander='{     "hint": "Hint expander for the radio button group",     "content": "Example hint expander content for the radio button group."   }'   required="true" > </ontario-radio-buttons>
		 */
		hintExpander?: HintExpander | string;
		/**
		 * Used to include the ontario-hint-text component for radio button group. This is optional.
		 */
		hintText?: string | Hint;
		/**
		 * The language of the component. This is used for translations, and is by default set through event listeners checking for a language property from the header. If no language is passed, it will default to English.
		 */
		language?: Language;
		/**
		 * The name assigned to the radio button. The name value is used to reference form data after a form is submitted.
		 */
		name: string;
		/**
		 * The options for the radio button group.  Each property will be passed in through an object in the options array. This can either be passed in as an object directly (if using react), or as a string in HTML. If there are multiple radio buttons in a group, each radio button will be displayed as an option.  In the example below, the options are being passed in as a string and there are two radio buttons to be displayed in the group.
		 * @example <ontario-radio-buttons   caption='{     "captionText": "Radio legend",     "captionType": "heading",   }'   name="radios"   hint-text="Hint text for the radio button group."   options='[     {        "value": "radio-option-1", 		  "elementId": "radio-1",        "label": "Radio option 1 label"     },     {        "value": "radio-option-2", 		  "elementId": "radio-2",        "label": "Radio option 2 label",        "hintExpander": { 		  "hint": "Hint expander for radio option 2", 		      "content": "Example hint expander content for radio option 2." 	  }      }   ]'   required="true" > </ontario-radio-buttons>
		 */
		options: string | RadioOption[];
		/**
		 * This is used to determine whether the radio button is required or not. This prop also gets passed to the InputCaption utility to display either an optional or required flag in the label. If no prop is set, it will default to false (optional).
		 */
		required?: boolean;
	}
	interface OntarioStepIndicator {
		/**
		 * URL for the back element to set a path for where the link will lead.  If a URL is passed in, the back element will display as an anchor tag. The back element will require either the backButtonURL prop or the customOnClick prop to be passed in order for the back element to display.
		 */
		backButtonUrl?: string;
		/**
		 * A number value to indicate which step the user is currently on.
		 */
		currentStep?: number;
		/**
		 * Used to add a custom function to the back button onClick event.  If this function is passed in, the back element will display as a button. The back element will require either the backButtonURL prop or the customOnClick prop to be passed in order for the back element to display.
		 */
		customOnClick?: (event: globalThis.Event) => void;
		/**
		 * The language of the component. This is used for translations, and is by default set through event listeners checking for a language property from the header. If none are passed, it will default to English.
		 */
		language?: Language;
		/**
		 * A number value to indicate to the user the total number of steps the form has.
		 */
		numberOfSteps?: number;
		/**
		 * A number value to indicate to the user the percentage of the form that has been completed.
		 */
		percentageComplete?: number;
		/**
		 * A boolean value to determine whether or not the back button is displayed for the step indicator.  This is optional. If no prop is passed, it will default to `false`.
		 */
		showBackButton?: boolean;
	}
	interface OntarioTable {
		/**
		 * Specifies the caption (or title) of the table.  This is optional.
		 */
		caption?: string | undefined;
		/**
		 * Used to specify whether or not table data in cells should have reduced top and bottom padding. This is useful for pages with multiple data-heavy tables such as a budget or financial data.  This is optional. By default it will be set to “false”.
		 */
		condensed?: boolean | undefined;
		/**
		 * Used to specify whether or not the table should extend the full width of its container.  This is optional. By default, it will be set to “false”
		 */
		fullWidth?: boolean | undefined;
		/**
		 * Used to define the columns of the table.
		 * @example ; <ontario-table table-columns='[ { "title": "Type of service", "key": "service" }, { "title": "Processing and delivery", "key": "processing" }, { "title": "Cost", "key": "cost", "type": "numeric" } ]' > </ontario-table>
		 */
		tableColumns: string | TableColumnOptions[];
		/**
		 * Used to define the table body data. Note that the keys passed to the `data` object in the tableData should match the keys of the columns defined in the tableColumns prop.
		 * @example <ontario-table  table-data='[    {      "data": {        "service": "Regular service (online)",        "processing": "15 business days plus delivery by Canada Post",        "cost": "$15"      }    },    {      "data": {        "service": "Premium service (online)",        "cost": "$45",        "processing": "5 business days including delivery by courier"      }    }  ]' > </ontario-table>
		 */
		tableData: string | TableRowOptions[];
		/**
		 * Indicates whether or not the table data should have alternate row zebra striping.  This is optional. By default, zebra striping will be added when the table rows extend 5 rows. If zebra striping is needed to table rows less than 5 rows, the prop should be set to “enabled”. If no zebra stripes are needed, it should be set to “disabled”.  The default will be set to “auto”.
		 */
		zebraStripes?: 'auto' | 'disabled' | 'enabled' | undefined;
	}
	interface OntarioTextarea {
		/**
		 * The text to display as the textarea label.
		 * @example <ontario-input   caption='{     "captionText": "Address",     "captionType": "heading",   }'   required="true"   ...> </ontario-input>
		 */
		caption: Caption | string;
		/**
		 * Used to add a custom function to the textarea onBlur event.
		 */
		customOnBlur?: (event: globalThis.Event) => void;
		/**
		 * Used to add a custom function to the textarea onChange event.
		 */
		customOnChange?: (event: globalThis.Event) => void;
		/**
		 * Used to add a custom function to the textarea onFocus event.
		 */
		customOnFocus?: (event: globalThis.Event) => void;
		/**
		 * Used to add a custom function to the textarea onInput event.
		 */
		customOnInput?: (event: globalThis.Event) => void;
		/**
		 * The unique identifier of the textarea. This is optional - if no ID is passed, one will be generated.
		 */
		elementId?: string;
		/**
		 * Used to include the ontario-hint-expander component for the textarea component. This is passed in as an object with key-value pairs.  This is optional.
		 * @example <ontario-textarea   caption='{     "captionText": "What are your thoughts",     "captionType": "heading",   }' 	 name: "textarea"   hint-expander='{     "hint": "This is the hint expander",     "content": "This is the content for the hint expander"   }'   required="true" > </ontario-textarea>
		 */
		hintExpander?: HintExpander | string;
		/**
		 * Used to include the ontario-hint-text component for the textarea. This is optional.
		 */
		hintText?: string | Hint;
		/**
		 * The language of the component. This is used for translations, and is by default set through event listeners checking for a language property from the header. If no language is passed, it will default to English.
		 */
		language?: Language;
		/**
		 * The name assigned to the textarea. The name value is used to reference form data after a form is submitted.
		 */
		name: string;
		/**
		 * This is used to determine whether the textarea is required or not. This prop also gets passed to the InputCaption utility to display either an optional or required flag in the label. If no prop is set, it will default to false (optional).
		 */
		required?: boolean;
		/**
		 * The textarea content value.
		 */
		value?: string;
	}
}
export interface OntarioCheckboxesCustomEvent<T> extends CustomEvent<T> {
	detail: T;
	target: HTMLOntarioCheckboxesElement;
}
export interface OntarioDateInputCustomEvent<T> extends CustomEvent<T> {
	detail: T;
	target: HTMLOntarioDateInputElement;
}
export interface OntarioDropdownListCustomEvent<T> extends CustomEvent<T> {
	detail: T;
	target: HTMLOntarioDropdownListElement;
}
export interface OntarioHintExpanderCustomEvent<T> extends CustomEvent<T> {
	detail: T;
	target: HTMLOntarioHintExpanderElement;
}
export interface OntarioInputCustomEvent<T> extends CustomEvent<T> {
	detail: T;
	target: HTMLOntarioInputElement;
}
export interface OntarioLanguageToggleCustomEvent<T> extends CustomEvent<T> {
	detail: T;
	target: HTMLOntarioLanguageToggleElement;
}
export interface OntarioRadioButtonsCustomEvent<T> extends CustomEvent<T> {
	detail: T;
	target: HTMLOntarioRadioButtonsElement;
}
export interface OntarioTextareaCustomEvent<T> extends CustomEvent<T> {
	detail: T;
	target: HTMLOntarioTextareaElement;
}
declare global {
	interface HTMLOntarioAccordionElement extends Components.OntarioAccordion, HTMLStencilElement {}
	var HTMLOntarioAccordionElement: {
		prototype: HTMLOntarioAccordionElement;
		new (): HTMLOntarioAccordionElement;
	};
	interface HTMLOntarioAsideElement extends Components.OntarioAside, HTMLStencilElement {}
	var HTMLOntarioAsideElement: {
		prototype: HTMLOntarioAsideElement;
		new (): HTMLOntarioAsideElement;
	};
	interface HTMLOntarioBackToTopElement extends Components.OntarioBackToTop, HTMLStencilElement {}
	var HTMLOntarioBackToTopElement: {
		prototype: HTMLOntarioBackToTopElement;
		new (): HTMLOntarioBackToTopElement;
	};
	interface HTMLOntarioBlockquoteElement extends Components.OntarioBlockquote, HTMLStencilElement {}
	var HTMLOntarioBlockquoteElement: {
		prototype: HTMLOntarioBlockquoteElement;
		new (): HTMLOntarioBlockquoteElement;
	};
	interface HTMLOntarioButtonElement extends Components.OntarioButton, HTMLStencilElement {}
	var HTMLOntarioButtonElement: {
		prototype: HTMLOntarioButtonElement;
		new (): HTMLOntarioButtonElement;
	};
	interface HTMLOntarioCalloutElement extends Components.OntarioCallout, HTMLStencilElement {}
	var HTMLOntarioCalloutElement: {
		prototype: HTMLOntarioCalloutElement;
		new (): HTMLOntarioCalloutElement;
	};
	interface HTMLOntarioCardElement extends Components.OntarioCard, HTMLStencilElement {}
	var HTMLOntarioCardElement: {
		prototype: HTMLOntarioCardElement;
		new (): HTMLOntarioCardElement;
	};
	interface HTMLOntarioCardCollectionElement extends Components.OntarioCardCollection, HTMLStencilElement {}
	var HTMLOntarioCardCollectionElement: {
		prototype: HTMLOntarioCardCollectionElement;
		new (): HTMLOntarioCardCollectionElement;
	};
	interface HTMLOntarioCheckboxesElementEventMap {
		checkboxOnChange: RadioAndCheckboxChangeEvent;
		checkboxOnBlur: InputFocusBlurEvent;
		checkboxOnFocus: InputFocusBlurEvent;
	}
	interface HTMLOntarioCheckboxesElement extends Components.OntarioCheckboxes, HTMLStencilElement {
		addEventListener<K extends keyof HTMLOntarioCheckboxesElementEventMap>(
			type: K,
			listener: (
				this: HTMLOntarioCheckboxesElement,
				ev: OntarioCheckboxesCustomEvent<HTMLOntarioCheckboxesElementEventMap[K]>,
			) => any,
			options?: boolean | AddEventListenerOptions,
		): void;
		addEventListener<K extends keyof DocumentEventMap>(
			type: K,
			listener: (this: Document, ev: DocumentEventMap[K]) => any,
			options?: boolean | AddEventListenerOptions,
		): void;
		addEventListener<K extends keyof HTMLElementEventMap>(
			type: K,
			listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any,
			options?: boolean | AddEventListenerOptions,
		): void;
		addEventListener(
			type: string,
			listener: EventListenerOrEventListenerObject,
			options?: boolean | AddEventListenerOptions,
		): void;
		removeEventListener<K extends keyof HTMLOntarioCheckboxesElementEventMap>(
			type: K,
			listener: (
				this: HTMLOntarioCheckboxesElement,
				ev: OntarioCheckboxesCustomEvent<HTMLOntarioCheckboxesElementEventMap[K]>,
			) => any,
			options?: boolean | EventListenerOptions,
		): void;
		removeEventListener<K extends keyof DocumentEventMap>(
			type: K,
			listener: (this: Document, ev: DocumentEventMap[K]) => any,
			options?: boolean | EventListenerOptions,
		): void;
		removeEventListener<K extends keyof HTMLElementEventMap>(
			type: K,
			listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any,
			options?: boolean | EventListenerOptions,
		): void;
		removeEventListener(
			type: string,
			listener: EventListenerOrEventListenerObject,
			options?: boolean | EventListenerOptions,
		): void;
	}
	var HTMLOntarioCheckboxesElement: {
		prototype: HTMLOntarioCheckboxesElement;
		new (): HTMLOntarioCheckboxesElement;
	};
	interface HTMLOntarioCriticalAlertElement extends Components.OntarioCriticalAlert, HTMLStencilElement {}
	var HTMLOntarioCriticalAlertElement: {
		prototype: HTMLOntarioCriticalAlertElement;
		new (): HTMLOntarioCriticalAlertElement;
	};
	interface HTMLOntarioDateInputElementEventMap {
		inputOnInput: {
			value: string;
			fieldType: 'day' | 'month' | 'year';
		};
		inputOnChange: {
			value: string;
			fieldType: 'day' | 'month' | 'year';
		};
		inputOnBlur: 'day' | 'month' | 'year';
		inputOnFocus: 'day' | 'month' | 'year';
		inputErrorOccurred: { inputId: string; errorMessage: string };
	}
	interface HTMLOntarioDateInputElement extends Components.OntarioDateInput, HTMLStencilElement {
		addEventListener<K extends keyof HTMLOntarioDateInputElementEventMap>(
			type: K,
			listener: (
				this: HTMLOntarioDateInputElement,
				ev: OntarioDateInputCustomEvent<HTMLOntarioDateInputElementEventMap[K]>,
			) => any,
			options?: boolean | AddEventListenerOptions,
		): void;
		addEventListener<K extends keyof DocumentEventMap>(
			type: K,
			listener: (this: Document, ev: DocumentEventMap[K]) => any,
			options?: boolean | AddEventListenerOptions,
		): void;
		addEventListener<K extends keyof HTMLElementEventMap>(
			type: K,
			listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any,
			options?: boolean | AddEventListenerOptions,
		): void;
		addEventListener(
			type: string,
			listener: EventListenerOrEventListenerObject,
			options?: boolean | AddEventListenerOptions,
		): void;
		removeEventListener<K extends keyof HTMLOntarioDateInputElementEventMap>(
			type: K,
			listener: (
				this: HTMLOntarioDateInputElement,
				ev: OntarioDateInputCustomEvent<HTMLOntarioDateInputElementEventMap[K]>,
			) => any,
			options?: boolean | EventListenerOptions,
		): void;
		removeEventListener<K extends keyof DocumentEventMap>(
			type: K,
			listener: (this: Document, ev: DocumentEventMap[K]) => any,
			options?: boolean | EventListenerOptions,
		): void;
		removeEventListener<K extends keyof HTMLElementEventMap>(
			type: K,
			listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any,
			options?: boolean | EventListenerOptions,
		): void;
		removeEventListener(
			type: string,
			listener: EventListenerOrEventListenerObject,
			options?: boolean | EventListenerOptions,
		): void;
	}
	var HTMLOntarioDateInputElement: {
		prototype: HTMLOntarioDateInputElement;
		new (): HTMLOntarioDateInputElement;
	};
	interface HTMLOntarioDropdownListElementEventMap {
		dropdownOnChange: InputInteractionEvent;
		dropdownOnBlur: InputFocusBlurEvent;
		dropdownOnFocus: InputFocusBlurEvent;
	}
	interface HTMLOntarioDropdownListElement extends Components.OntarioDropdownList, HTMLStencilElement {
		addEventListener<K extends keyof HTMLOntarioDropdownListElementEventMap>(
			type: K,
			listener: (
				this: HTMLOntarioDropdownListElement,
				ev: OntarioDropdownListCustomEvent<HTMLOntarioDropdownListElementEventMap[K]>,
			) => any,
			options?: boolean | AddEventListenerOptions,
		): void;
		addEventListener<K extends keyof DocumentEventMap>(
			type: K,
			listener: (this: Document, ev: DocumentEventMap[K]) => any,
			options?: boolean | AddEventListenerOptions,
		): void;
		addEventListener<K extends keyof HTMLElementEventMap>(
			type: K,
			listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any,
			options?: boolean | AddEventListenerOptions,
		): void;
		addEventListener(
			type: string,
			listener: EventListenerOrEventListenerObject,
			options?: boolean | AddEventListenerOptions,
		): void;
		removeEventListener<K extends keyof HTMLOntarioDropdownListElementEventMap>(
			type: K,
			listener: (
				this: HTMLOntarioDropdownListElement,
				ev: OntarioDropdownListCustomEvent<HTMLOntarioDropdownListElementEventMap[K]>,
			) => any,
			options?: boolean | EventListenerOptions,
		): void;
		removeEventListener<K extends keyof DocumentEventMap>(
			type: K,
			listener: (this: Document, ev: DocumentEventMap[K]) => any,
			options?: boolean | EventListenerOptions,
		): void;
		removeEventListener<K extends keyof HTMLElementEventMap>(
			type: K,
			listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any,
			options?: boolean | EventListenerOptions,
		): void;
		removeEventListener(
			type: string,
			listener: EventListenerOrEventListenerObject,
			options?: boolean | EventListenerOptions,
		): void;
	}
	var HTMLOntarioDropdownListElement: {
		prototype: HTMLOntarioDropdownListElement;
		new (): HTMLOntarioDropdownListElement;
	};
	interface HTMLOntarioFieldsetElement extends Components.OntarioFieldset, HTMLStencilElement {}
	var HTMLOntarioFieldsetElement: {
		prototype: HTMLOntarioFieldsetElement;
		new (): HTMLOntarioFieldsetElement;
	};
	interface HTMLOntarioFooterElement extends Components.OntarioFooter, HTMLStencilElement {}
	var HTMLOntarioFooterElement: {
		prototype: HTMLOntarioFooterElement;
		new (): HTMLOntarioFooterElement;
	};
	interface HTMLOntarioHeaderElement extends Components.OntarioHeader, HTMLStencilElement {}
	var HTMLOntarioHeaderElement: {
		prototype: HTMLOntarioHeaderElement;
		new (): HTMLOntarioHeaderElement;
	};
	interface HTMLOntarioHintExpanderElementEventMap {
		toggleExpanderEvent: MouseEvent | KeyboardEvent;
	}
	interface HTMLOntarioHintExpanderElement extends Components.OntarioHintExpander, HTMLStencilElement {
		addEventListener<K extends keyof HTMLOntarioHintExpanderElementEventMap>(
			type: K,
			listener: (
				this: HTMLOntarioHintExpanderElement,
				ev: OntarioHintExpanderCustomEvent<HTMLOntarioHintExpanderElementEventMap[K]>,
			) => any,
			options?: boolean | AddEventListenerOptions,
		): void;
		addEventListener<K extends keyof DocumentEventMap>(
			type: K,
			listener: (this: Document, ev: DocumentEventMap[K]) => any,
			options?: boolean | AddEventListenerOptions,
		): void;
		addEventListener<K extends keyof HTMLElementEventMap>(
			type: K,
			listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any,
			options?: boolean | AddEventListenerOptions,
		): void;
		addEventListener(
			type: string,
			listener: EventListenerOrEventListenerObject,
			options?: boolean | AddEventListenerOptions,
		): void;
		removeEventListener<K extends keyof HTMLOntarioHintExpanderElementEventMap>(
			type: K,
			listener: (
				this: HTMLOntarioHintExpanderElement,
				ev: OntarioHintExpanderCustomEvent<HTMLOntarioHintExpanderElementEventMap[K]>,
			) => any,
			options?: boolean | EventListenerOptions,
		): void;
		removeEventListener<K extends keyof DocumentEventMap>(
			type: K,
			listener: (this: Document, ev: DocumentEventMap[K]) => any,
			options?: boolean | EventListenerOptions,
		): void;
		removeEventListener<K extends keyof HTMLElementEventMap>(
			type: K,
			listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any,
			options?: boolean | EventListenerOptions,
		): void;
		removeEventListener(
			type: string,
			listener: EventListenerOrEventListenerObject,
			options?: boolean | EventListenerOptions,
		): void;
	}
	var HTMLOntarioHintExpanderElement: {
		prototype: HTMLOntarioHintExpanderElement;
		new (): HTMLOntarioHintExpanderElement;
	};
	interface HTMLOntarioHintTextElement extends Components.OntarioHintText, HTMLStencilElement {}
	var HTMLOntarioHintTextElement: {
		prototype: HTMLOntarioHintTextElement;
		new (): HTMLOntarioHintTextElement;
	};
	interface HTMLOntarioIconAccessibilityElement extends Components.OntarioIconAccessibility, HTMLStencilElement {}
	var HTMLOntarioIconAccessibilityElement: {
		prototype: HTMLOntarioIconAccessibilityElement;
		new (): HTMLOntarioIconAccessibilityElement;
	};
	interface HTMLOntarioIconAccountElement extends Components.OntarioIconAccount, HTMLStencilElement {}
	var HTMLOntarioIconAccountElement: {
		prototype: HTMLOntarioIconAccountElement;
		new (): HTMLOntarioIconAccountElement;
	};
	interface HTMLOntarioIconAddElement extends Components.OntarioIconAdd, HTMLStencilElement {}
	var HTMLOntarioIconAddElement: {
		prototype: HTMLOntarioIconAddElement;
		new (): HTMLOntarioIconAddElement;
	};
	interface HTMLOntarioIconAddAltElement extends Components.OntarioIconAddAlt, HTMLStencilElement {}
	var HTMLOntarioIconAddAltElement: {
		prototype: HTMLOntarioIconAddAltElement;
		new (): HTMLOntarioIconAddAltElement;
	};
	interface HTMLOntarioIconAlertErrorElement extends Components.OntarioIconAlertError, HTMLStencilElement {}
	var HTMLOntarioIconAlertErrorElement: {
		prototype: HTMLOntarioIconAlertErrorElement;
		new (): HTMLOntarioIconAlertErrorElement;
	};
	interface HTMLOntarioIconAlertInformationElement extends Components.OntarioIconAlertInformation, HTMLStencilElement {}
	var HTMLOntarioIconAlertInformationElement: {
		prototype: HTMLOntarioIconAlertInformationElement;
		new (): HTMLOntarioIconAlertInformationElement;
	};
	interface HTMLOntarioIconAlertSuccessElement extends Components.OntarioIconAlertSuccess, HTMLStencilElement {}
	var HTMLOntarioIconAlertSuccessElement: {
		prototype: HTMLOntarioIconAlertSuccessElement;
		new (): HTMLOntarioIconAlertSuccessElement;
	};
	interface HTMLOntarioIconAlertWarningElement extends Components.OntarioIconAlertWarning, HTMLStencilElement {}
	var HTMLOntarioIconAlertWarningElement: {
		prototype: HTMLOntarioIconAlertWarningElement;
		new (): HTMLOntarioIconAlertWarningElement;
	};
	interface HTMLOntarioIconArrowUpElement extends Components.OntarioIconArrowUp, HTMLStencilElement {}
	var HTMLOntarioIconArrowUpElement: {
		prototype: HTMLOntarioIconArrowUpElement;
		new (): HTMLOntarioIconArrowUpElement;
	};
	interface HTMLOntarioIconAttachElement extends Components.OntarioIconAttach, HTMLStencilElement {}
	var HTMLOntarioIconAttachElement: {
		prototype: HTMLOntarioIconAttachElement;
		new (): HTMLOntarioIconAttachElement;
	};
	interface HTMLOntarioIconBookmarkOffElement extends Components.OntarioIconBookmarkOff, HTMLStencilElement {}
	var HTMLOntarioIconBookmarkOffElement: {
		prototype: HTMLOntarioIconBookmarkOffElement;
		new (): HTMLOntarioIconBookmarkOffElement;
	};
	interface HTMLOntarioIconBookmarkOnElement extends Components.OntarioIconBookmarkOn, HTMLStencilElement {}
	var HTMLOntarioIconBookmarkOnElement: {
		prototype: HTMLOntarioIconBookmarkOnElement;
		new (): HTMLOntarioIconBookmarkOnElement;
	};
	interface HTMLOntarioIconCalendarElement extends Components.OntarioIconCalendar, HTMLStencilElement {}
	var HTMLOntarioIconCalendarElement: {
		prototype: HTMLOntarioIconCalendarElement;
		new (): HTMLOntarioIconCalendarElement;
	};
	interface HTMLOntarioIconCameraElement extends Components.OntarioIconCamera, HTMLStencilElement {}
	var HTMLOntarioIconCameraElement: {
		prototype: HTMLOntarioIconCameraElement;
		new (): HTMLOntarioIconCameraElement;
	};
	interface HTMLOntarioIconChevronDownElement extends Components.OntarioIconChevronDown, HTMLStencilElement {}
	var HTMLOntarioIconChevronDownElement: {
		prototype: HTMLOntarioIconChevronDownElement;
		new (): HTMLOntarioIconChevronDownElement;
	};
	interface HTMLOntarioIconChevronLeftElement extends Components.OntarioIconChevronLeft, HTMLStencilElement {}
	var HTMLOntarioIconChevronLeftElement: {
		prototype: HTMLOntarioIconChevronLeftElement;
		new (): HTMLOntarioIconChevronLeftElement;
	};
	interface HTMLOntarioIconChevronRightElement extends Components.OntarioIconChevronRight, HTMLStencilElement {}
	var HTMLOntarioIconChevronRightElement: {
		prototype: HTMLOntarioIconChevronRightElement;
		new (): HTMLOntarioIconChevronRightElement;
	};
	interface HTMLOntarioIconChevronUpElement extends Components.OntarioIconChevronUp, HTMLStencilElement {}
	var HTMLOntarioIconChevronUpElement: {
		prototype: HTMLOntarioIconChevronUpElement;
		new (): HTMLOntarioIconChevronUpElement;
	};
	interface HTMLOntarioIconClockElement extends Components.OntarioIconClock, HTMLStencilElement {}
	var HTMLOntarioIconClockElement: {
		prototype: HTMLOntarioIconClockElement;
		new (): HTMLOntarioIconClockElement;
	};
	interface HTMLOntarioIconCloseElement extends Components.OntarioIconClose, HTMLStencilElement {}
	var HTMLOntarioIconCloseElement: {
		prototype: HTMLOntarioIconCloseElement;
		new (): HTMLOntarioIconCloseElement;
	};
	interface HTMLOntarioIconCloseHeaderElement extends Components.OntarioIconCloseHeader, HTMLStencilElement {}
	var HTMLOntarioIconCloseHeaderElement: {
		prototype: HTMLOntarioIconCloseHeaderElement;
		new (): HTMLOntarioIconCloseHeaderElement;
	};
	interface HTMLOntarioIconCloudElement extends Components.OntarioIconCloud, HTMLStencilElement {}
	var HTMLOntarioIconCloudElement: {
		prototype: HTMLOntarioIconCloudElement;
		new (): HTMLOntarioIconCloudElement;
	};
	interface HTMLOntarioIconCollapseElement extends Components.OntarioIconCollapse, HTMLStencilElement {}
	var HTMLOntarioIconCollapseElement: {
		prototype: HTMLOntarioIconCollapseElement;
		new (): HTMLOntarioIconCollapseElement;
	};
	interface HTMLOntarioIconCreditCardElement extends Components.OntarioIconCreditCard, HTMLStencilElement {}
	var HTMLOntarioIconCreditCardElement: {
		prototype: HTMLOntarioIconCreditCardElement;
		new (): HTMLOntarioIconCreditCardElement;
	};
	interface HTMLOntarioIconCriticalAlertWarningElement
		extends Components.OntarioIconCriticalAlertWarning,
			HTMLStencilElement {}
	var HTMLOntarioIconCriticalAlertWarningElement: {
		prototype: HTMLOntarioIconCriticalAlertWarningElement;
		new (): HTMLOntarioIconCriticalAlertWarningElement;
	};
	interface HTMLOntarioIconDeleteElement extends Components.OntarioIconDelete, HTMLStencilElement {}
	var HTMLOntarioIconDeleteElement: {
		prototype: HTMLOntarioIconDeleteElement;
		new (): HTMLOntarioIconDeleteElement;
	};
	interface HTMLOntarioIconDocumentElement extends Components.OntarioIconDocument, HTMLStencilElement {}
	var HTMLOntarioIconDocumentElement: {
		prototype: HTMLOntarioIconDocumentElement;
		new (): HTMLOntarioIconDocumentElement;
	};
	interface HTMLOntarioIconDownloadElement extends Components.OntarioIconDownload, HTMLStencilElement {}
	var HTMLOntarioIconDownloadElement: {
		prototype: HTMLOntarioIconDownloadElement;
		new (): HTMLOntarioIconDownloadElement;
	};
	interface HTMLOntarioIconDropdownArrowElement extends Components.OntarioIconDropdownArrow, HTMLStencilElement {}
	var HTMLOntarioIconDropdownArrowElement: {
		prototype: HTMLOntarioIconDropdownArrowElement;
		new (): HTMLOntarioIconDropdownArrowElement;
	};
	interface HTMLOntarioIconEditElement extends Components.OntarioIconEdit, HTMLStencilElement {}
	var HTMLOntarioIconEditElement: {
		prototype: HTMLOntarioIconEditElement;
		new (): HTMLOntarioIconEditElement;
	};
	interface HTMLOntarioIconEmailElement extends Components.OntarioIconEmail, HTMLStencilElement {}
	var HTMLOntarioIconEmailElement: {
		prototype: HTMLOntarioIconEmailElement;
		new (): HTMLOntarioIconEmailElement;
	};
	interface HTMLOntarioIconExpandElement extends Components.OntarioIconExpand, HTMLStencilElement {}
	var HTMLOntarioIconExpandElement: {
		prototype: HTMLOntarioIconExpandElement;
		new (): HTMLOntarioIconExpandElement;
	};
	interface HTMLOntarioIconExportElement extends Components.OntarioIconExport, HTMLStencilElement {}
	var HTMLOntarioIconExportElement: {
		prototype: HTMLOntarioIconExportElement;
		new (): HTMLOntarioIconExportElement;
	};
	interface HTMLOntarioIconFacebookElement extends Components.OntarioIconFacebook, HTMLStencilElement {}
	var HTMLOntarioIconFacebookElement: {
		prototype: HTMLOntarioIconFacebookElement;
		new (): HTMLOntarioIconFacebookElement;
	};
	interface HTMLOntarioIconFacebookAltElement extends Components.OntarioIconFacebookAlt, HTMLStencilElement {}
	var HTMLOntarioIconFacebookAltElement: {
		prototype: HTMLOntarioIconFacebookAltElement;
		new (): HTMLOntarioIconFacebookAltElement;
	};
	interface HTMLOntarioIconFavouriteOffElement extends Components.OntarioIconFavouriteOff, HTMLStencilElement {}
	var HTMLOntarioIconFavouriteOffElement: {
		prototype: HTMLOntarioIconFavouriteOffElement;
		new (): HTMLOntarioIconFavouriteOffElement;
	};
	interface HTMLOntarioIconFavouriteOnElement extends Components.OntarioIconFavouriteOn, HTMLStencilElement {}
	var HTMLOntarioIconFavouriteOnElement: {
		prototype: HTMLOntarioIconFavouriteOnElement;
		new (): HTMLOntarioIconFavouriteOnElement;
	};
	interface HTMLOntarioIconFilterElement extends Components.OntarioIconFilter, HTMLStencilElement {}
	var HTMLOntarioIconFilterElement: {
		prototype: HTMLOntarioIconFilterElement;
		new (): HTMLOntarioIconFilterElement;
	};
	interface HTMLOntarioIconFlickrElement extends Components.OntarioIconFlickr, HTMLStencilElement {}
	var HTMLOntarioIconFlickrElement: {
		prototype: HTMLOntarioIconFlickrElement;
		new (): HTMLOntarioIconFlickrElement;
	};
	interface HTMLOntarioIconGridElement extends Components.OntarioIconGrid, HTMLStencilElement {}
	var HTMLOntarioIconGridElement: {
		prototype: HTMLOntarioIconGridElement;
		new (): HTMLOntarioIconGridElement;
	};
	interface HTMLOntarioIconHelpElement extends Components.OntarioIconHelp, HTMLStencilElement {}
	var HTMLOntarioIconHelpElement: {
		prototype: HTMLOntarioIconHelpElement;
		new (): HTMLOntarioIconHelpElement;
	};
	interface HTMLOntarioIconInstagramElement extends Components.OntarioIconInstagram, HTMLStencilElement {}
	var HTMLOntarioIconInstagramElement: {
		prototype: HTMLOntarioIconInstagramElement;
		new (): HTMLOntarioIconInstagramElement;
	};
	interface HTMLOntarioIconInteracEnElement extends Components.OntarioIconInteracEn, HTMLStencilElement {}
	var HTMLOntarioIconInteracEnElement: {
		prototype: HTMLOntarioIconInteracEnElement;
		new (): HTMLOntarioIconInteracEnElement;
	};
	interface HTMLOntarioIconInteracEnAltElement extends Components.OntarioIconInteracEnAlt, HTMLStencilElement {}
	var HTMLOntarioIconInteracEnAltElement: {
		prototype: HTMLOntarioIconInteracEnAltElement;
		new (): HTMLOntarioIconInteracEnAltElement;
	};
	interface HTMLOntarioIconInteracFrElement extends Components.OntarioIconInteracFr, HTMLStencilElement {}
	var HTMLOntarioIconInteracFrElement: {
		prototype: HTMLOntarioIconInteracFrElement;
		new (): HTMLOntarioIconInteracFrElement;
	};
	interface HTMLOntarioIconInteracFrAltElement extends Components.OntarioIconInteracFrAlt, HTMLStencilElement {}
	var HTMLOntarioIconInteracFrAltElement: {
		prototype: HTMLOntarioIconInteracFrAltElement;
		new (): HTMLOntarioIconInteracFrAltElement;
	};
	interface HTMLOntarioIconLinkedinElement extends Components.OntarioIconLinkedin, HTMLStencilElement {}
	var HTMLOntarioIconLinkedinElement: {
		prototype: HTMLOntarioIconLinkedinElement;
		new (): HTMLOntarioIconLinkedinElement;
	};
	interface HTMLOntarioIconLinkedinAltElement extends Components.OntarioIconLinkedinAlt, HTMLStencilElement {}
	var HTMLOntarioIconLinkedinAltElement: {
		prototype: HTMLOntarioIconLinkedinAltElement;
		new (): HTMLOntarioIconLinkedinAltElement;
	};
	interface HTMLOntarioIconListElement extends Components.OntarioIconList, HTMLStencilElement {}
	var HTMLOntarioIconListElement: {
		prototype: HTMLOntarioIconListElement;
		new (): HTMLOntarioIconListElement;
	};
	interface HTMLOntarioIconLiveChatElement extends Components.OntarioIconLiveChat, HTMLStencilElement {}
	var HTMLOntarioIconLiveChatElement: {
		prototype: HTMLOntarioIconLiveChatElement;
		new (): HTMLOntarioIconLiveChatElement;
	};
	interface HTMLOntarioIconLocationOffElement extends Components.OntarioIconLocationOff, HTMLStencilElement {}
	var HTMLOntarioIconLocationOffElement: {
		prototype: HTMLOntarioIconLocationOffElement;
		new (): HTMLOntarioIconLocationOffElement;
	};
	interface HTMLOntarioIconLocationOnElement extends Components.OntarioIconLocationOn, HTMLStencilElement {}
	var HTMLOntarioIconLocationOnElement: {
		prototype: HTMLOntarioIconLocationOnElement;
		new (): HTMLOntarioIconLocationOnElement;
	};
	interface HTMLOntarioIconLockOffElement extends Components.OntarioIconLockOff, HTMLStencilElement {}
	var HTMLOntarioIconLockOffElement: {
		prototype: HTMLOntarioIconLockOffElement;
		new (): HTMLOntarioIconLockOffElement;
	};
	interface HTMLOntarioIconLockOnElement extends Components.OntarioIconLockOn, HTMLStencilElement {}
	var HTMLOntarioIconLockOnElement: {
		prototype: HTMLOntarioIconLockOnElement;
		new (): HTMLOntarioIconLockOnElement;
	};
	interface HTMLOntarioIconMapElement extends Components.OntarioIconMap, HTMLStencilElement {}
	var HTMLOntarioIconMapElement: {
		prototype: HTMLOntarioIconMapElement;
		new (): HTMLOntarioIconMapElement;
	};
	interface HTMLOntarioIconMastercardElement extends Components.OntarioIconMastercard, HTMLStencilElement {}
	var HTMLOntarioIconMastercardElement: {
		prototype: HTMLOntarioIconMastercardElement;
		new (): HTMLOntarioIconMastercardElement;
	};
	interface HTMLOntarioIconMastercardAltElement extends Components.OntarioIconMastercardAlt, HTMLStencilElement {}
	var HTMLOntarioIconMastercardAltElement: {
		prototype: HTMLOntarioIconMastercardAltElement;
		new (): HTMLOntarioIconMastercardAltElement;
	};
	interface HTMLOntarioIconMediaFastForwardElement extends Components.OntarioIconMediaFastForward, HTMLStencilElement {}
	var HTMLOntarioIconMediaFastForwardElement: {
		prototype: HTMLOntarioIconMediaFastForwardElement;
		new (): HTMLOntarioIconMediaFastForwardElement;
	};
	interface HTMLOntarioIconMediaFastRewindElement extends Components.OntarioIconMediaFastRewind, HTMLStencilElement {}
	var HTMLOntarioIconMediaFastRewindElement: {
		prototype: HTMLOntarioIconMediaFastRewindElement;
		new (): HTMLOntarioIconMediaFastRewindElement;
	};
	interface HTMLOntarioIconMediaPauseElement extends Components.OntarioIconMediaPause, HTMLStencilElement {}
	var HTMLOntarioIconMediaPauseElement: {
		prototype: HTMLOntarioIconMediaPauseElement;
		new (): HTMLOntarioIconMediaPauseElement;
	};
	interface HTMLOntarioIconMediaPlayElement extends Components.OntarioIconMediaPlay, HTMLStencilElement {}
	var HTMLOntarioIconMediaPlayElement: {
		prototype: HTMLOntarioIconMediaPlayElement;
		new (): HTMLOntarioIconMediaPlayElement;
	};
	interface HTMLOntarioIconMediaStopElement extends Components.OntarioIconMediaStop, HTMLStencilElement {}
	var HTMLOntarioIconMediaStopElement: {
		prototype: HTMLOntarioIconMediaStopElement;
		new (): HTMLOntarioIconMediaStopElement;
	};
	interface HTMLOntarioIconMenuElement extends Components.OntarioIconMenu, HTMLStencilElement {}
	var HTMLOntarioIconMenuElement: {
		prototype: HTMLOntarioIconMenuElement;
		new (): HTMLOntarioIconMenuElement;
	};
	interface HTMLOntarioIconMenuHeaderElement extends Components.OntarioIconMenuHeader, HTMLStencilElement {}
	var HTMLOntarioIconMenuHeaderElement: {
		prototype: HTMLOntarioIconMenuHeaderElement;
		new (): HTMLOntarioIconMenuHeaderElement;
	};
	interface HTMLOntarioIconMicrophoneOffElement extends Components.OntarioIconMicrophoneOff, HTMLStencilElement {}
	var HTMLOntarioIconMicrophoneOffElement: {
		prototype: HTMLOntarioIconMicrophoneOffElement;
		new (): HTMLOntarioIconMicrophoneOffElement;
	};
	interface HTMLOntarioIconMicrophoneOnElement extends Components.OntarioIconMicrophoneOn, HTMLStencilElement {}
	var HTMLOntarioIconMicrophoneOnElement: {
		prototype: HTMLOntarioIconMicrophoneOnElement;
		new (): HTMLOntarioIconMicrophoneOnElement;
	};
	interface HTMLOntarioIconMoreVerticalElement extends Components.OntarioIconMoreVertical, HTMLStencilElement {}
	var HTMLOntarioIconMoreVerticalElement: {
		prototype: HTMLOntarioIconMoreVerticalElement;
		new (): HTMLOntarioIconMoreVerticalElement;
	};
	interface HTMLOntarioIconNewWindowElement extends Components.OntarioIconNewWindow, HTMLStencilElement {}
	var HTMLOntarioIconNewWindowElement: {
		prototype: HTMLOntarioIconNewWindowElement;
		new (): HTMLOntarioIconNewWindowElement;
	};
	interface HTMLOntarioIconNextElement extends Components.OntarioIconNext, HTMLStencilElement {}
	var HTMLOntarioIconNextElement: {
		prototype: HTMLOntarioIconNextElement;
		new (): HTMLOntarioIconNextElement;
	};
	interface HTMLOntarioIconNotificationElement extends Components.OntarioIconNotification, HTMLStencilElement {}
	var HTMLOntarioIconNotificationElement: {
		prototype: HTMLOntarioIconNotificationElement;
		new (): HTMLOntarioIconNotificationElement;
	};
	interface HTMLOntarioIconPasswordHideElement extends Components.OntarioIconPasswordHide, HTMLStencilElement {}
	var HTMLOntarioIconPasswordHideElement: {
		prototype: HTMLOntarioIconPasswordHideElement;
		new (): HTMLOntarioIconPasswordHideElement;
	};
	interface HTMLOntarioIconPasswordShowElement extends Components.OntarioIconPasswordShow, HTMLStencilElement {}
	var HTMLOntarioIconPasswordShowElement: {
		prototype: HTMLOntarioIconPasswordShowElement;
		new (): HTMLOntarioIconPasswordShowElement;
	};
	interface HTMLOntarioIconPhoneElement extends Components.OntarioIconPhone, HTMLStencilElement {}
	var HTMLOntarioIconPhoneElement: {
		prototype: HTMLOntarioIconPhoneElement;
		new (): HTMLOntarioIconPhoneElement;
	};
	interface HTMLOntarioIconPhotoElement extends Components.OntarioIconPhoto, HTMLStencilElement {}
	var HTMLOntarioIconPhotoElement: {
		prototype: HTMLOntarioIconPhotoElement;
		new (): HTMLOntarioIconPhotoElement;
	};
	interface HTMLOntarioIconPinLocationOffElement extends Components.OntarioIconPinLocationOff, HTMLStencilElement {}
	var HTMLOntarioIconPinLocationOffElement: {
		prototype: HTMLOntarioIconPinLocationOffElement;
		new (): HTMLOntarioIconPinLocationOffElement;
	};
	interface HTMLOntarioIconPinLocationOnElement extends Components.OntarioIconPinLocationOn, HTMLStencilElement {}
	var HTMLOntarioIconPinLocationOnElement: {
		prototype: HTMLOntarioIconPinLocationOnElement;
		new (): HTMLOntarioIconPinLocationOnElement;
	};
	interface HTMLOntarioIconPreviousElement extends Components.OntarioIconPrevious, HTMLStencilElement {}
	var HTMLOntarioIconPreviousElement: {
		prototype: HTMLOntarioIconPreviousElement;
		new (): HTMLOntarioIconPreviousElement;
	};
	interface HTMLOntarioIconPrintElement extends Components.OntarioIconPrint, HTMLStencilElement {}
	var HTMLOntarioIconPrintElement: {
		prototype: HTMLOntarioIconPrintElement;
		new (): HTMLOntarioIconPrintElement;
	};
	interface HTMLOntarioIconRemoveElement extends Components.OntarioIconRemove, HTMLStencilElement {}
	var HTMLOntarioIconRemoveElement: {
		prototype: HTMLOntarioIconRemoveElement;
		new (): HTMLOntarioIconRemoveElement;
	};
	interface HTMLOntarioIconRemoveAltElement extends Components.OntarioIconRemoveAlt, HTMLStencilElement {}
	var HTMLOntarioIconRemoveAltElement: {
		prototype: HTMLOntarioIconRemoveAltElement;
		new (): HTMLOntarioIconRemoveAltElement;
	};
	interface HTMLOntarioIconReplayElement extends Components.OntarioIconReplay, HTMLStencilElement {}
	var HTMLOntarioIconReplayElement: {
		prototype: HTMLOntarioIconReplayElement;
		new (): HTMLOntarioIconReplayElement;
	};
	interface HTMLOntarioIconRssFeedElement extends Components.OntarioIconRssFeed, HTMLStencilElement {}
	var HTMLOntarioIconRssFeedElement: {
		prototype: HTMLOntarioIconRssFeedElement;
		new (): HTMLOntarioIconRssFeedElement;
	};
	interface HTMLOntarioIconSaveElement extends Components.OntarioIconSave, HTMLStencilElement {}
	var HTMLOntarioIconSaveElement: {
		prototype: HTMLOntarioIconSaveElement;
		new (): HTMLOntarioIconSaveElement;
	};
	interface HTMLOntarioIconSearchElement extends Components.OntarioIconSearch, HTMLStencilElement {}
	var HTMLOntarioIconSearchElement: {
		prototype: HTMLOntarioIconSearchElement;
		new (): HTMLOntarioIconSearchElement;
	};
	interface HTMLOntarioIconSearchWhiteElement extends Components.OntarioIconSearchWhite, HTMLStencilElement {}
	var HTMLOntarioIconSearchWhiteElement: {
		prototype: HTMLOntarioIconSearchWhiteElement;
		new (): HTMLOntarioIconSearchWhiteElement;
	};
	interface HTMLOntarioIconSentiment1Element extends Components.OntarioIconSentiment1, HTMLStencilElement {}
	var HTMLOntarioIconSentiment1Element: {
		prototype: HTMLOntarioIconSentiment1Element;
		new (): HTMLOntarioIconSentiment1Element;
	};
	interface HTMLOntarioIconSentiment2Element extends Components.OntarioIconSentiment2, HTMLStencilElement {}
	var HTMLOntarioIconSentiment2Element: {
		prototype: HTMLOntarioIconSentiment2Element;
		new (): HTMLOntarioIconSentiment2Element;
	};
	interface HTMLOntarioIconSentiment3Element extends Components.OntarioIconSentiment3, HTMLStencilElement {}
	var HTMLOntarioIconSentiment3Element: {
		prototype: HTMLOntarioIconSentiment3Element;
		new (): HTMLOntarioIconSentiment3Element;
	};
	interface HTMLOntarioIconSentiment4Element extends Components.OntarioIconSentiment4, HTMLStencilElement {}
	var HTMLOntarioIconSentiment4Element: {
		prototype: HTMLOntarioIconSentiment4Element;
		new (): HTMLOntarioIconSentiment4Element;
	};
	interface HTMLOntarioIconSentiment5Element extends Components.OntarioIconSentiment5, HTMLStencilElement {}
	var HTMLOntarioIconSentiment5Element: {
		prototype: HTMLOntarioIconSentiment5Element;
		new (): HTMLOntarioIconSentiment5Element;
	};
	interface HTMLOntarioIconSettingsElement extends Components.OntarioIconSettings, HTMLStencilElement {}
	var HTMLOntarioIconSettingsElement: {
		prototype: HTMLOntarioIconSettingsElement;
		new (): HTMLOntarioIconSettingsElement;
	};
	interface HTMLOntarioIconShareElement extends Components.OntarioIconShare, HTMLStencilElement {}
	var HTMLOntarioIconShareElement: {
		prototype: HTMLOntarioIconShareElement;
		new (): HTMLOntarioIconShareElement;
	};
	interface HTMLOntarioIconSortElement extends Components.OntarioIconSort, HTMLStencilElement {}
	var HTMLOntarioIconSortElement: {
		prototype: HTMLOntarioIconSortElement;
		new (): HTMLOntarioIconSortElement;
	};
	interface HTMLOntarioIconTagElement extends Components.OntarioIconTag, HTMLStencilElement {}
	var HTMLOntarioIconTagElement: {
		prototype: HTMLOntarioIconTagElement;
		new (): HTMLOntarioIconTagElement;
	};
	interface HTMLOntarioIconTextMessageElement extends Components.OntarioIconTextMessage, HTMLStencilElement {}
	var HTMLOntarioIconTextMessageElement: {
		prototype: HTMLOntarioIconTextMessageElement;
		new (): HTMLOntarioIconTextMessageElement;
	};
	interface HTMLOntarioIconTimerElement extends Components.OntarioIconTimer, HTMLStencilElement {}
	var HTMLOntarioIconTimerElement: {
		prototype: HTMLOntarioIconTimerElement;
		new (): HTMLOntarioIconTimerElement;
	};
	interface HTMLOntarioIconTransportBicycleElement extends Components.OntarioIconTransportBicycle, HTMLStencilElement {}
	var HTMLOntarioIconTransportBicycleElement: {
		prototype: HTMLOntarioIconTransportBicycleElement;
		new (): HTMLOntarioIconTransportBicycleElement;
	};
	interface HTMLOntarioIconTransportBusElement extends Components.OntarioIconTransportBus, HTMLStencilElement {}
	var HTMLOntarioIconTransportBusElement: {
		prototype: HTMLOntarioIconTransportBusElement;
		new (): HTMLOntarioIconTransportBusElement;
	};
	interface HTMLOntarioIconTransportCarElement extends Components.OntarioIconTransportCar, HTMLStencilElement {}
	var HTMLOntarioIconTransportCarElement: {
		prototype: HTMLOntarioIconTransportCarElement;
		new (): HTMLOntarioIconTransportCarElement;
	};
	interface HTMLOntarioIconTransportWalkElement extends Components.OntarioIconTransportWalk, HTMLStencilElement {}
	var HTMLOntarioIconTransportWalkElement: {
		prototype: HTMLOntarioIconTransportWalkElement;
		new (): HTMLOntarioIconTransportWalkElement;
	};
	interface HTMLOntarioIconTtyElement extends Components.OntarioIconTty, HTMLStencilElement {}
	var HTMLOntarioIconTtyElement: {
		prototype: HTMLOntarioIconTtyElement;
		new (): HTMLOntarioIconTtyElement;
	};
	interface HTMLOntarioIconTwitterElement extends Components.OntarioIconTwitter, HTMLStencilElement {}
	var HTMLOntarioIconTwitterElement: {
		prototype: HTMLOntarioIconTwitterElement;
		new (): HTMLOntarioIconTwitterElement;
	};
	interface HTMLOntarioIconTwitterAltElement extends Components.OntarioIconTwitterAlt, HTMLStencilElement {}
	var HTMLOntarioIconTwitterAltElement: {
		prototype: HTMLOntarioIconTwitterAltElement;
		new (): HTMLOntarioIconTwitterAltElement;
	};
	interface HTMLOntarioIconUploadElement extends Components.OntarioIconUpload, HTMLStencilElement {}
	var HTMLOntarioIconUploadElement: {
		prototype: HTMLOntarioIconUploadElement;
		new (): HTMLOntarioIconUploadElement;
	};
	interface HTMLOntarioIconVideoElement extends Components.OntarioIconVideo, HTMLStencilElement {}
	var HTMLOntarioIconVideoElement: {
		prototype: HTMLOntarioIconVideoElement;
		new (): HTMLOntarioIconVideoElement;
	};
	interface HTMLOntarioIconVisaElement extends Components.OntarioIconVisa, HTMLStencilElement {}
	var HTMLOntarioIconVisaElement: {
		prototype: HTMLOntarioIconVisaElement;
		new (): HTMLOntarioIconVisaElement;
	};
	interface HTMLOntarioIconVoteDislikeElement extends Components.OntarioIconVoteDislike, HTMLStencilElement {}
	var HTMLOntarioIconVoteDislikeElement: {
		prototype: HTMLOntarioIconVoteDislikeElement;
		new (): HTMLOntarioIconVoteDislikeElement;
	};
	interface HTMLOntarioIconVoteLikeElement extends Components.OntarioIconVoteLike, HTMLStencilElement {}
	var HTMLOntarioIconVoteLikeElement: {
		prototype: HTMLOntarioIconVoteLikeElement;
		new (): HTMLOntarioIconVoteLikeElement;
	};
	interface HTMLOntarioIconVpnKeyElement extends Components.OntarioIconVpnKey, HTMLStencilElement {}
	var HTMLOntarioIconVpnKeyElement: {
		prototype: HTMLOntarioIconVpnKeyElement;
		new (): HTMLOntarioIconVpnKeyElement;
	};
	interface HTMLOntarioIconWheelchairElement extends Components.OntarioIconWheelchair, HTMLStencilElement {}
	var HTMLOntarioIconWheelchairElement: {
		prototype: HTMLOntarioIconWheelchairElement;
		new (): HTMLOntarioIconWheelchairElement;
	};
	interface HTMLOntarioIconWifiElement extends Components.OntarioIconWifi, HTMLStencilElement {}
	var HTMLOntarioIconWifiElement: {
		prototype: HTMLOntarioIconWifiElement;
		new (): HTMLOntarioIconWifiElement;
	};
	interface HTMLOntarioIconYoutubeElement extends Components.OntarioIconYoutube, HTMLStencilElement {}
	var HTMLOntarioIconYoutubeElement: {
		prototype: HTMLOntarioIconYoutubeElement;
		new (): HTMLOntarioIconYoutubeElement;
	};
	interface HTMLOntarioInputElementEventMap {
		inputOnInput: InputInputEvent;
		inputOnChange: InputInteractionEvent;
		inputOnBlur: InputFocusBlurEvent;
		inputOnFocus: InputFocusBlurEvent;
		inputErrorOccurred: { inputId: string; errorMessage: string };
	}
	interface HTMLOntarioInputElement extends Components.OntarioInput, HTMLStencilElement {
		addEventListener<K extends keyof HTMLOntarioInputElementEventMap>(
			type: K,
			listener: (this: HTMLOntarioInputElement, ev: OntarioInputCustomEvent<HTMLOntarioInputElementEventMap[K]>) => any,
			options?: boolean | AddEventListenerOptions,
		): void;
		addEventListener<K extends keyof DocumentEventMap>(
			type: K,
			listener: (this: Document, ev: DocumentEventMap[K]) => any,
			options?: boolean | AddEventListenerOptions,
		): void;
		addEventListener<K extends keyof HTMLElementEventMap>(
			type: K,
			listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any,
			options?: boolean | AddEventListenerOptions,
		): void;
		addEventListener(
			type: string,
			listener: EventListenerOrEventListenerObject,
			options?: boolean | AddEventListenerOptions,
		): void;
		removeEventListener<K extends keyof HTMLOntarioInputElementEventMap>(
			type: K,
			listener: (this: HTMLOntarioInputElement, ev: OntarioInputCustomEvent<HTMLOntarioInputElementEventMap[K]>) => any,
			options?: boolean | EventListenerOptions,
		): void;
		removeEventListener<K extends keyof DocumentEventMap>(
			type: K,
			listener: (this: Document, ev: DocumentEventMap[K]) => any,
			options?: boolean | EventListenerOptions,
		): void;
		removeEventListener<K extends keyof HTMLElementEventMap>(
			type: K,
			listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any,
			options?: boolean | EventListenerOptions,
		): void;
		removeEventListener(
			type: string,
			listener: EventListenerOrEventListenerObject,
			options?: boolean | EventListenerOptions,
		): void;
	}
	var HTMLOntarioInputElement: {
		prototype: HTMLOntarioInputElement;
		new (): HTMLOntarioInputElement;
	};
	interface HTMLOntarioLanguageToggleElementEventMap {
		setAppLanguage: string;
		headerLanguageToggled: HeaderLanguageToggleEventDetails;
	}
	interface HTMLOntarioLanguageToggleElement extends Components.OntarioLanguageToggle, HTMLStencilElement {
		addEventListener<K extends keyof HTMLOntarioLanguageToggleElementEventMap>(
			type: K,
			listener: (
				this: HTMLOntarioLanguageToggleElement,
				ev: OntarioLanguageToggleCustomEvent<HTMLOntarioLanguageToggleElementEventMap[K]>,
			) => any,
			options?: boolean | AddEventListenerOptions,
		): void;
		addEventListener<K extends keyof DocumentEventMap>(
			type: K,
			listener: (this: Document, ev: DocumentEventMap[K]) => any,
			options?: boolean | AddEventListenerOptions,
		): void;
		addEventListener<K extends keyof HTMLElementEventMap>(
			type: K,
			listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any,
			options?: boolean | AddEventListenerOptions,
		): void;
		addEventListener(
			type: string,
			listener: EventListenerOrEventListenerObject,
			options?: boolean | AddEventListenerOptions,
		): void;
		removeEventListener<K extends keyof HTMLOntarioLanguageToggleElementEventMap>(
			type: K,
			listener: (
				this: HTMLOntarioLanguageToggleElement,
				ev: OntarioLanguageToggleCustomEvent<HTMLOntarioLanguageToggleElementEventMap[K]>,
			) => any,
			options?: boolean | EventListenerOptions,
		): void;
		removeEventListener<K extends keyof DocumentEventMap>(
			type: K,
			listener: (this: Document, ev: DocumentEventMap[K]) => any,
			options?: boolean | EventListenerOptions,
		): void;
		removeEventListener<K extends keyof HTMLElementEventMap>(
			type: K,
			listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any,
			options?: boolean | EventListenerOptions,
		): void;
		removeEventListener(
			type: string,
			listener: EventListenerOrEventListenerObject,
			options?: boolean | EventListenerOptions,
		): void;
	}
	var HTMLOntarioLanguageToggleElement: {
		prototype: HTMLOntarioLanguageToggleElement;
		new (): HTMLOntarioLanguageToggleElement;
	};
	interface HTMLOntarioLoadingIndicatorElement extends Components.OntarioLoadingIndicator, HTMLStencilElement {}
	var HTMLOntarioLoadingIndicatorElement: {
		prototype: HTMLOntarioLoadingIndicatorElement;
		new (): HTMLOntarioLoadingIndicatorElement;
	};
	interface HTMLOntarioPageAlertElement extends Components.OntarioPageAlert, HTMLStencilElement {}
	var HTMLOntarioPageAlertElement: {
		prototype: HTMLOntarioPageAlertElement;
		new (): HTMLOntarioPageAlertElement;
	};
	interface HTMLOntarioRadioButtonsElementEventMap {
		radioOnChange: RadioAndCheckboxChangeEvent;
		radioOnBlur: InputFocusBlurEvent;
		radioOnFocus: InputFocusBlurEvent;
	}
	interface HTMLOntarioRadioButtonsElement extends Components.OntarioRadioButtons, HTMLStencilElement {
		addEventListener<K extends keyof HTMLOntarioRadioButtonsElementEventMap>(
			type: K,
			listener: (
				this: HTMLOntarioRadioButtonsElement,
				ev: OntarioRadioButtonsCustomEvent<HTMLOntarioRadioButtonsElementEventMap[K]>,
			) => any,
			options?: boolean | AddEventListenerOptions,
		): void;
		addEventListener<K extends keyof DocumentEventMap>(
			type: K,
			listener: (this: Document, ev: DocumentEventMap[K]) => any,
			options?: boolean | AddEventListenerOptions,
		): void;
		addEventListener<K extends keyof HTMLElementEventMap>(
			type: K,
			listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any,
			options?: boolean | AddEventListenerOptions,
		): void;
		addEventListener(
			type: string,
			listener: EventListenerOrEventListenerObject,
			options?: boolean | AddEventListenerOptions,
		): void;
		removeEventListener<K extends keyof HTMLOntarioRadioButtonsElementEventMap>(
			type: K,
			listener: (
				this: HTMLOntarioRadioButtonsElement,
				ev: OntarioRadioButtonsCustomEvent<HTMLOntarioRadioButtonsElementEventMap[K]>,
			) => any,
			options?: boolean | EventListenerOptions,
		): void;
		removeEventListener<K extends keyof DocumentEventMap>(
			type: K,
			listener: (this: Document, ev: DocumentEventMap[K]) => any,
			options?: boolean | EventListenerOptions,
		): void;
		removeEventListener<K extends keyof HTMLElementEventMap>(
			type: K,
			listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any,
			options?: boolean | EventListenerOptions,
		): void;
		removeEventListener(
			type: string,
			listener: EventListenerOrEventListenerObject,
			options?: boolean | EventListenerOptions,
		): void;
	}
	var HTMLOntarioRadioButtonsElement: {
		prototype: HTMLOntarioRadioButtonsElement;
		new (): HTMLOntarioRadioButtonsElement;
	};
	interface HTMLOntarioStepIndicatorElement extends Components.OntarioStepIndicator, HTMLStencilElement {}
	var HTMLOntarioStepIndicatorElement: {
		prototype: HTMLOntarioStepIndicatorElement;
		new (): HTMLOntarioStepIndicatorElement;
	};
	interface HTMLOntarioTableElement extends Components.OntarioTable, HTMLStencilElement {}
	var HTMLOntarioTableElement: {
		prototype: HTMLOntarioTableElement;
		new (): HTMLOntarioTableElement;
	};
	interface HTMLOntarioTextareaElementEventMap {
		inputOnInput: InputInputEvent;
		inputOnChange: InputInteractionEvent;
		inputOnBlur: InputFocusBlurEvent;
		inputOnFocus: InputFocusBlurEvent;
	}
	interface HTMLOntarioTextareaElement extends Components.OntarioTextarea, HTMLStencilElement {
		addEventListener<K extends keyof HTMLOntarioTextareaElementEventMap>(
			type: K,
			listener: (
				this: HTMLOntarioTextareaElement,
				ev: OntarioTextareaCustomEvent<HTMLOntarioTextareaElementEventMap[K]>,
			) => any,
			options?: boolean | AddEventListenerOptions,
		): void;
		addEventListener<K extends keyof DocumentEventMap>(
			type: K,
			listener: (this: Document, ev: DocumentEventMap[K]) => any,
			options?: boolean | AddEventListenerOptions,
		): void;
		addEventListener<K extends keyof HTMLElementEventMap>(
			type: K,
			listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any,
			options?: boolean | AddEventListenerOptions,
		): void;
		addEventListener(
			type: string,
			listener: EventListenerOrEventListenerObject,
			options?: boolean | AddEventListenerOptions,
		): void;
		removeEventListener<K extends keyof HTMLOntarioTextareaElementEventMap>(
			type: K,
			listener: (
				this: HTMLOntarioTextareaElement,
				ev: OntarioTextareaCustomEvent<HTMLOntarioTextareaElementEventMap[K]>,
			) => any,
			options?: boolean | EventListenerOptions,
		): void;
		removeEventListener<K extends keyof DocumentEventMap>(
			type: K,
			listener: (this: Document, ev: DocumentEventMap[K]) => any,
			options?: boolean | EventListenerOptions,
		): void;
		removeEventListener<K extends keyof HTMLElementEventMap>(
			type: K,
			listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any,
			options?: boolean | EventListenerOptions,
		): void;
		removeEventListener(
			type: string,
			listener: EventListenerOrEventListenerObject,
			options?: boolean | EventListenerOptions,
		): void;
	}
	var HTMLOntarioTextareaElement: {
		prototype: HTMLOntarioTextareaElement;
		new (): HTMLOntarioTextareaElement;
	};
	interface HTMLElementTagNameMap {
		'ontario-accordion': HTMLOntarioAccordionElement;
		'ontario-aside': HTMLOntarioAsideElement;
		'ontario-back-to-top': HTMLOntarioBackToTopElement;
		'ontario-blockquote': HTMLOntarioBlockquoteElement;
		'ontario-button': HTMLOntarioButtonElement;
		'ontario-callout': HTMLOntarioCalloutElement;
		'ontario-card': HTMLOntarioCardElement;
		'ontario-card-collection': HTMLOntarioCardCollectionElement;
		'ontario-checkboxes': HTMLOntarioCheckboxesElement;
		'ontario-critical-alert': HTMLOntarioCriticalAlertElement;
		'ontario-date-input': HTMLOntarioDateInputElement;
		'ontario-dropdown-list': HTMLOntarioDropdownListElement;
		'ontario-fieldset': HTMLOntarioFieldsetElement;
		'ontario-footer': HTMLOntarioFooterElement;
		'ontario-header': HTMLOntarioHeaderElement;
		'ontario-hint-expander': HTMLOntarioHintExpanderElement;
		'ontario-hint-text': HTMLOntarioHintTextElement;
		'ontario-icon-accessibility': HTMLOntarioIconAccessibilityElement;
		'ontario-icon-account': HTMLOntarioIconAccountElement;
		'ontario-icon-add': HTMLOntarioIconAddElement;
		'ontario-icon-add-alt': HTMLOntarioIconAddAltElement;
		'ontario-icon-alert-error': HTMLOntarioIconAlertErrorElement;
		'ontario-icon-alert-information': HTMLOntarioIconAlertInformationElement;
		'ontario-icon-alert-success': HTMLOntarioIconAlertSuccessElement;
		'ontario-icon-alert-warning': HTMLOntarioIconAlertWarningElement;
		'ontario-icon-arrow-up': HTMLOntarioIconArrowUpElement;
		'ontario-icon-attach': HTMLOntarioIconAttachElement;
		'ontario-icon-bookmark-off': HTMLOntarioIconBookmarkOffElement;
		'ontario-icon-bookmark-on': HTMLOntarioIconBookmarkOnElement;
		'ontario-icon-calendar': HTMLOntarioIconCalendarElement;
		'ontario-icon-camera': HTMLOntarioIconCameraElement;
		'ontario-icon-chevron-down': HTMLOntarioIconChevronDownElement;
		'ontario-icon-chevron-left': HTMLOntarioIconChevronLeftElement;
		'ontario-icon-chevron-right': HTMLOntarioIconChevronRightElement;
		'ontario-icon-chevron-up': HTMLOntarioIconChevronUpElement;
		'ontario-icon-clock': HTMLOntarioIconClockElement;
		'ontario-icon-close': HTMLOntarioIconCloseElement;
		'ontario-icon-close-header': HTMLOntarioIconCloseHeaderElement;
		'ontario-icon-cloud': HTMLOntarioIconCloudElement;
		'ontario-icon-collapse': HTMLOntarioIconCollapseElement;
		'ontario-icon-credit-card': HTMLOntarioIconCreditCardElement;
		'ontario-icon-critical-alert-warning': HTMLOntarioIconCriticalAlertWarningElement;
		'ontario-icon-delete': HTMLOntarioIconDeleteElement;
		'ontario-icon-document': HTMLOntarioIconDocumentElement;
		'ontario-icon-download': HTMLOntarioIconDownloadElement;
		'ontario-icon-dropdown-arrow': HTMLOntarioIconDropdownArrowElement;
		'ontario-icon-edit': HTMLOntarioIconEditElement;
		'ontario-icon-email': HTMLOntarioIconEmailElement;
		'ontario-icon-expand': HTMLOntarioIconExpandElement;
		'ontario-icon-export': HTMLOntarioIconExportElement;
		'ontario-icon-facebook': HTMLOntarioIconFacebookElement;
		'ontario-icon-facebook-alt': HTMLOntarioIconFacebookAltElement;
		'ontario-icon-favourite-off': HTMLOntarioIconFavouriteOffElement;
		'ontario-icon-favourite-on': HTMLOntarioIconFavouriteOnElement;
		'ontario-icon-filter': HTMLOntarioIconFilterElement;
		'ontario-icon-flickr': HTMLOntarioIconFlickrElement;
		'ontario-icon-grid': HTMLOntarioIconGridElement;
		'ontario-icon-help': HTMLOntarioIconHelpElement;
		'ontario-icon-instagram': HTMLOntarioIconInstagramElement;
		'ontario-icon-interac-en': HTMLOntarioIconInteracEnElement;
		'ontario-icon-interac-en-alt': HTMLOntarioIconInteracEnAltElement;
		'ontario-icon-interac-fr': HTMLOntarioIconInteracFrElement;
		'ontario-icon-interac-fr-alt': HTMLOntarioIconInteracFrAltElement;
		'ontario-icon-linkedin': HTMLOntarioIconLinkedinElement;
		'ontario-icon-linkedin-alt': HTMLOntarioIconLinkedinAltElement;
		'ontario-icon-list': HTMLOntarioIconListElement;
		'ontario-icon-live-chat': HTMLOntarioIconLiveChatElement;
		'ontario-icon-location-off': HTMLOntarioIconLocationOffElement;
		'ontario-icon-location-on': HTMLOntarioIconLocationOnElement;
		'ontario-icon-lock-off': HTMLOntarioIconLockOffElement;
		'ontario-icon-lock-on': HTMLOntarioIconLockOnElement;
		'ontario-icon-map': HTMLOntarioIconMapElement;
		'ontario-icon-mastercard': HTMLOntarioIconMastercardElement;
		'ontario-icon-mastercard-alt': HTMLOntarioIconMastercardAltElement;
		'ontario-icon-media-fast-forward': HTMLOntarioIconMediaFastForwardElement;
		'ontario-icon-media-fast-rewind': HTMLOntarioIconMediaFastRewindElement;
		'ontario-icon-media-pause': HTMLOntarioIconMediaPauseElement;
		'ontario-icon-media-play': HTMLOntarioIconMediaPlayElement;
		'ontario-icon-media-stop': HTMLOntarioIconMediaStopElement;
		'ontario-icon-menu': HTMLOntarioIconMenuElement;
		'ontario-icon-menu-header': HTMLOntarioIconMenuHeaderElement;
		'ontario-icon-microphone-off': HTMLOntarioIconMicrophoneOffElement;
		'ontario-icon-microphone-on': HTMLOntarioIconMicrophoneOnElement;
		'ontario-icon-more-vertical': HTMLOntarioIconMoreVerticalElement;
		'ontario-icon-new-window': HTMLOntarioIconNewWindowElement;
		'ontario-icon-next': HTMLOntarioIconNextElement;
		'ontario-icon-notification': HTMLOntarioIconNotificationElement;
		'ontario-icon-password-hide': HTMLOntarioIconPasswordHideElement;
		'ontario-icon-password-show': HTMLOntarioIconPasswordShowElement;
		'ontario-icon-phone': HTMLOntarioIconPhoneElement;
		'ontario-icon-photo': HTMLOntarioIconPhotoElement;
		'ontario-icon-pin-location-off': HTMLOntarioIconPinLocationOffElement;
		'ontario-icon-pin-location-on': HTMLOntarioIconPinLocationOnElement;
		'ontario-icon-previous': HTMLOntarioIconPreviousElement;
		'ontario-icon-print': HTMLOntarioIconPrintElement;
		'ontario-icon-remove': HTMLOntarioIconRemoveElement;
		'ontario-icon-remove-alt': HTMLOntarioIconRemoveAltElement;
		'ontario-icon-replay': HTMLOntarioIconReplayElement;
		'ontario-icon-rss-feed': HTMLOntarioIconRssFeedElement;
		'ontario-icon-save': HTMLOntarioIconSaveElement;
		'ontario-icon-search': HTMLOntarioIconSearchElement;
		'ontario-icon-search-white': HTMLOntarioIconSearchWhiteElement;
		'ontario-icon-sentiment-1': HTMLOntarioIconSentiment1Element;
		'ontario-icon-sentiment-2': HTMLOntarioIconSentiment2Element;
		'ontario-icon-sentiment-3': HTMLOntarioIconSentiment3Element;
		'ontario-icon-sentiment-4': HTMLOntarioIconSentiment4Element;
		'ontario-icon-sentiment-5': HTMLOntarioIconSentiment5Element;
		'ontario-icon-settings': HTMLOntarioIconSettingsElement;
		'ontario-icon-share': HTMLOntarioIconShareElement;
		'ontario-icon-sort': HTMLOntarioIconSortElement;
		'ontario-icon-tag': HTMLOntarioIconTagElement;
		'ontario-icon-text-message': HTMLOntarioIconTextMessageElement;
		'ontario-icon-timer': HTMLOntarioIconTimerElement;
		'ontario-icon-transport-bicycle': HTMLOntarioIconTransportBicycleElement;
		'ontario-icon-transport-bus': HTMLOntarioIconTransportBusElement;
		'ontario-icon-transport-car': HTMLOntarioIconTransportCarElement;
		'ontario-icon-transport-walk': HTMLOntarioIconTransportWalkElement;
		'ontario-icon-tty': HTMLOntarioIconTtyElement;
		'ontario-icon-twitter': HTMLOntarioIconTwitterElement;
		'ontario-icon-twitter-alt': HTMLOntarioIconTwitterAltElement;
		'ontario-icon-upload': HTMLOntarioIconUploadElement;
		'ontario-icon-video': HTMLOntarioIconVideoElement;
		'ontario-icon-visa': HTMLOntarioIconVisaElement;
		'ontario-icon-vote-dislike': HTMLOntarioIconVoteDislikeElement;
		'ontario-icon-vote-like': HTMLOntarioIconVoteLikeElement;
		'ontario-icon-vpn-key': HTMLOntarioIconVpnKeyElement;
		'ontario-icon-wheelchair': HTMLOntarioIconWheelchairElement;
		'ontario-icon-wifi': HTMLOntarioIconWifiElement;
		'ontario-icon-youtube': HTMLOntarioIconYoutubeElement;
		'ontario-input': HTMLOntarioInputElement;
		'ontario-language-toggle': HTMLOntarioLanguageToggleElement;
		'ontario-loading-indicator': HTMLOntarioLoadingIndicatorElement;
		'ontario-page-alert': HTMLOntarioPageAlertElement;
		'ontario-radio-buttons': HTMLOntarioRadioButtonsElement;
		'ontario-step-indicator': HTMLOntarioStepIndicatorElement;
		'ontario-table': HTMLOntarioTableElement;
		'ontario-textarea': HTMLOntarioTextareaElement;
	}
}
declare namespace LocalJSX {
	interface OntarioAccordion {
		/**
		 * Used to include individual accordion data for the accordion component. This is passed in as an array of objects with key-value pairs.  The `content` is expecting a string, that can either be written as HTML or a just a plain string, depending on the accordionContentType.
		 * @example 	<ontario-accordion 	name="My Accordion" 	accordion-data='[ 		{"label": "Accordion 1", "content": "This is a string"}, 		{"label": "Accordion 2", "accordionContentType": "html", "content": "<ul><li>List A</li><li>List B</li><li>List C</li></ul>"} 	]' ></ontario-accordion>
		 */
		accordionData?: string | Accordion[];
		/**
		 * Custom Expand/Collapse button text.
		 * @example  <ontario-accordion 	name="My Accordion" 	expand-collapse-button='{ 		"expandAllSectionsLabel": "Expand All", 		"collapseAllSectionsLabel": "Collapse All" 	}' 	accordion-data='[ 		{"label": "Accordion 1", "content": ["Item 1", "Item 2", "Item 3"]}, 		{"label": "Accordion 2", "content": ["Item A", "Item B", "Item C"]} 	]' ></ontario-accordion>
		 */
		expandCollapseButton?: string | ExpandCollapseButtonDetails;
		/**
		 * Used to show whether the accordion is opened or closed.
		 */
		isOpen?: boolean;
		/**
		 * The language of the component. This is used for translations, and is by default set through event listeners checking for a language property from the header. If none are passed, it will default to English.
		 */
		language?: Language;
		/**
		 * The name of the accordion component.  This is not optional.
		 */
		name?: string;
	}
	interface OntarioAside {
		/**
		 * Optional text to be displayed as the content for the aside component. If a string is passed, it will automatically be nested in a paragraph tag.  HTML content can also be passed as the child/children of the aside component if additional/different elements for the content are needed.
		 * @example <ontario-aside headingType='h3' headingContent='This is the aside heading'><p>This is the first sentence of the aside content.</p><p>This is the second sentence of the aside content.</p></ontario-aside>
		 */
		content?: string;
		/**
		 * Text or HTML to be displayed as the heading of the aside. If the heading content should be displayed as HTML, the `headingContentType` needs to be set to `html`.
		 */
		headingContent?: string;
		/**
		 * The type of the heading content. If no prop is passed, it will default to string.
		 */
		headingContentType?: HeadingContentType;
		/**
		 * The heading level of the aside heading.
		 */
		headingType?: HeadingLevelOptions;
		/**
		 * Optional prop to choose the border colour of the aside. If none is passed, the default colour will be teal.
		 */
		highlightColour?: HighlightColourOptions;
	}
	interface OntarioBackToTop {
		/**
		 * The language of the component. This is used for translations, and is by default set through event listeners checking for a language property from the header. If no language prop is passed, it will default to English.
		 */
		language?: Language;
	}
	interface OntarioBlockquote {
		/**
		 * Optional text to be displayed as the attribution (the author) of the quote.
		 */
		attribution?: string;
		/**
		 * Optional text to be displayed for additional information about the attribution/author.
		 */
		byline?: string;
		/**
		 * Text to be displayed as the quote.  Note that wrapping the quotes in quotations is not needed - this is handled through the component styles
		 */
		quote?: string;
	}
	interface OntarioButton {
		/**
		 * Provides more context as to what the button interaction is doing. This should only be used for accessibility purposes, if the button interaction requires more description than what the text provides.   This is optional.
		 * @example <ontario-button aria-label-text="Click button to open map">Open</ontario button>
		 */
		ariaLabelText?: string;
		/**
		 * The unique identifier of the button. This is optional - if no ID is passed, one will be generated.
		 */
		elementId?: string;
		/**
		 * The native HTML button type the button should use.  If no htmlType is passed, it will default to 'button'.
		 */
		htmlType?: HtmlType;
		/**
		 * Text to be displayed within the button. This will override the text provided through the host element textContent.
		 * @example <ontario-button label="Label Text">Text</ontario-button>  The resulting button will have the label `"Label Text"`.
		 */
		label?: string;
		/**
		 * The type of button to render.  If no type is passed, it will default to 'secondary'.
		 */
		type?: ButtonType;
	}
	interface OntarioCallout {
		/**
		 * Optional text to be displayed as the content for the callout component. If a string is passed, it will automatically be nested in a paragraph tag.  HTML content can also be passed as the child/children of the callout component if additional/different elements for the content are needed.
		 * @example <ontario-callout headingType='h3' headingContent='This is the callout heading'><p>This is the first sentence of the callout content.</p><p>This is the second sentence of the callout content.</p></ontario-callout>
		 */
		content?: string;
		/**
		 * Text or HTML to be displayed as the heading of the callout. If the heading content should be displayed as HTML, the `headingContentType` needs to be set to `html`.
		 */
		headingContent?: string;
		/**
		 * The type of the heading content. If no prop is passed, it will default to `string`.
		 */
		headingContentType?: HeadingContentType;
		/**
		 * The heading level of the callout heading.
		 */
		headingType?: HeadingLevelOptions;
		/**
		 * Optional prop to choose the border colour of the callout. If none is passed, the default colour will be teal.
		 */
		highlightColour?: HighlightColourOptions;
	}
	interface OntarioCard {
		/**
		 * Provides more context as to what the card interaction is doing. This should only be used for accessibility purposes, if the card interaction requires more * * description than what the text provides.  This is optional.
		 */
		ariaLabelText?: string;
		/**
		 * Action link for when the card is clicked.  This is optional.
		 */
		cardLink?: string;
		/**
		 * The type of card to render.  If no type is passed, it will default to 'basic'.
		 */
		cardType?: CardType;
		/**
		 * Text to be displayed within the card description container.  This is optional.
		 */
		description?: string;
		/**
		 * The type of header to render.  If no type is passed, it will default to 'default'.
		 */
		headerType?: HeaderType;
		/**
		 * The position of the image when the card-type is set to 'horizontal'.  This prop is only necessry when the card-type is set to 'horizontal'.
		 * @example 	<ontario-card 	card-type="horizontal" 	label="Card Title 1" 	image="https://picsum.photos/200/300" 	horizontal-image-position-type="left" 	horizontal-image-size-type="one-fourth"   description="Lorem Ipsum Lorem Ipsum Lorem Ipsum Lorem Ipsum Lorem Ipsum Lorem Ipsum Lorem Ipsum Lorem Ipsum" > </ontario-card>
		 */
		horizontalImagePositionType?: HorizontalImagePositionType;
		/**
		 * The size of the image when the card-type is set to 'horizontal'.  This prop is only necessry when the card-type is set to 'horizontal'.
		 * @example 	<ontario-card 	card-type="horizontal" 	label="Card Title 1" 	image="https://picsum.photos/200/300" 	horizontal-image-position-type="left" 	horizontal-image-size-type="one-fourth"   description="Lorem Ipsum Lorem Ipsum Lorem Ipsum Lorem Ipsum Lorem Ipsum Lorem Ipsum Lorem Ipsum Lorem Ipsum" > </ontario-card>
		 */
		horizontalImageSizeType?: HorizontalImageSizeType;
		/**
		 * Image to be displayed within the card image container.  This is optional.
		 */
		image?: string;
		/**
		 * Text to be displayed within the header.
		 * @example <ontario-card 	header-type="dark" 	card-type="horizontal" 	label="Card Title 1" 	description="Lorem Ipsum Lorem Ipsum Lorem Ipsum Lorem Ipsum Lorem Ipsum Lorem Ipsum Lorem Ipsum Lorem Ipsum" >
		 */
		label?: string;
	}
	interface OntarioCardCollection {
		/**
		 * The number of cards to display per row.  If no number is passed, it will default to 3.
		 */
		cardsPerRow?: CardsPerRow;
	}
	interface OntarioCheckboxes {
		/**
		 * The text to display for the checkbox legend.
		 * @example <ontario-checkboxes   caption='{     "captionText": "Checkbox legend",     "captionType": "heading",   }   ...> </ontario-checkboxes>
		 */
		caption?: Caption | string;
		/**
		 * Used to add a custom function to the checkbox onBlur event.
		 */
		customOnBlur?: (event: globalThis.Event) => void;
		/**
		 * Used to add a custom function to the checkbox onChange event.
		 */
		customOnChange?: (event: globalThis.Event) => void;
		/**
		 * Used to add a custom function to the checkbox onFocus event.
		 */
		customOnFocus?: (event: globalThis.Event) => void;
		/**
		 * Used to include the ontario-hint-expander component for the checkbox group. This is passed in as an object with key-value pairs.  This is optional.
		 * @example <ontario-checkboxes   caption='{     "captionText": "Checkbox legend",     "captionType": "heading",   }   name='ontario-checkboxes'   options='[ 	{ 		"value": "checkbox-option-1", 		"label": "Checkbox option 1 label", 		"elementId": "checkbox-1" 	}   }]'   hint-expander='{    "hint": "Hint expander for the checkbox group",    "content": "Example hint expander content for the checkbox group"   }'   required="true" > </ontario-checkboxes>
		 */
		hintExpander?: HintExpander | string;
		/**
		 * Used to include the ontario-hint-text component for the checkbox group. This is optional.
		 */
		hintText?: string | Hint;
		/**
		 * The language of the component. This is used for translations, and is by default set through event listeners checking for a language property from the header. If no language is passed, it will default to English.
		 */
		language?: Language;
		/**
		 * The name for the checkboxes. The name value is used to reference form data after a form is submitted.
		 */
		name?: string;
		/**
		 * Emitted when a keyboard input event occurs when a checkbox option has lost focus.
		 */
		onCheckboxOnBlur?: (event: OntarioCheckboxesCustomEvent<InputFocusBlurEvent>) => void;
		/**
		 * Emitted when a keyboard input or mouse event occurs when a checkbox option has been changed.
		 */
		onCheckboxOnChange?: (event: OntarioCheckboxesCustomEvent<RadioAndCheckboxChangeEvent>) => void;
		/**
		 * Emitted when a keyboard input event occurs when a checkbox option has gained focus.
		 */
		onCheckboxOnFocus?: (event: OntarioCheckboxesCustomEvent<InputFocusBlurEvent>) => void;
		/**
		 * The options for the checkbox group.  Each property will be passed in through an object in the options array. This can either be passed in as an object directly (if using react), or as a string in HTML. If there are multiple checkboxes in a fieldset, each checkbox will be displayed as an option.  In the example below, the options are being passed in as a string and there are two checkboxes to be displayed in the fieldset.
		 * @example <ontario-checkboxes   caption='{ 	"captionText": "Checkbox legend", 	"captionType": "heading",   }   name="ontario-checkboxes",   hint-text="Hint text for the checkbox group."   options='[ 	{ 		"value": "checkbox-option-1", 		"label": "Checkbox option 1 label" 		"elementId": "checkbox-1"     },     {        "value": "checkbox-option-2",        "label": "Checkbox option 2 label", 		  "elementId": "checkbox-2",       "hintExpander": { 			"hint": "Hint expander for checkbox option 2",              "content": "Example hint expander content for checkbox option 2"        }      }   ]'   required="true" > </ontario-checkboxes>
		 */
		options?: CheckboxOption[] | string;
		/**
		 * This is used to determine whether the checkbox is required or not. This prop also gets passed to the InputCaption utility to display either an optional or required flag in the label. If no prop is set, it will default to false (optional).
		 */
		required?: boolean;
	}
	interface OntarioCriticalAlert {
		/**
		 * Content for critical alert message. It can be either string or HTML content. The content is already wrapped in a paragraph tag, so if using HTML content, the paragraph tag can be ommitted.
		 * @example <ontario-critical-alert content="COVID-19 State of emergency extended until May 12, 2020."></ontario-critical-alert>  or  <ontario-critical-alert>  <a href="#">COVID-19 State of emergency</a> extended until May 12, 2020. </ontario-critical-alert>
		 */
		content?: string | HTMLElement;
	}
	interface OntarioDateInput {
		/**
		 * The text to display as the input label
		 * @example <ontario-date-input   caption='{     "captionText": "Exact Date",     "captionType": "heading",   }   required="true"   ...> </ontario-date-input>
		 */
		caption?: Caption | string;
		/**
		 * An array value used to display date options. For example, only the day and month fields can be displayed by specifying the dateOptions as `["day", "month"]`, etc.  This is optional. If no prop for `dateOptions` is passed, it will default to `["day", "month", "year"]`.
		 */
		dateOptions?: string | Array<DateInputFieldType>;
		/**
		 * A function used to override internal date validation logic, which takes three arguments (i.e day, month and year) and returns an object of type `DateValidatorReturnType`  This is optional. If no prop for `dateValidator` is passed, it will default to internal validation function to validate the date input.
		 */
		dateValidator?: (day: string, month: string, year: string) => DateValidatorReturnType;
		/**
		 * The unique identifier of the input. This is optional - if no ID is passed, one will be generated.
		 */
		elementId?: string;
		/**
		 * Used to include the ontario-hint-text component for the date input group.  This is optional.
		 */
		hintText?: string;
		/**
		 * The language of the component. This is used for translations, and is by default set through event listeners checking for a language property from the header. If none are passed, it will default to English.
		 */
		language?: Language;
		/**
		 * A number value indicating maximum value allowed for year input field of the date component.  This is optional. If no prop is passed, it will default to `9999`.
		 */
		maxYear?: number;
		/**
		 * A number value indicating minimum value allowed for year input field of the date component.  This is optional. If no prop is passed, it will default to `999`.
		 */
		minYear?: number;
		/**
		 * Emitted when an error message is reported to the component.
		 */
		onInputErrorOccurred?: (event: OntarioDateInputCustomEvent<{ inputId: string; errorMessage: string }>) => void;
		/**
		 * Emitted when a keyboard input event occurs when an input has lost focus.
		 */
		onInputOnBlur?: (event: OntarioDateInputCustomEvent<'day' | 'month' | 'year'>) => void;
		/**
		 * Emitted when a `change` event occurs within the component.
		 */
		onInputOnChange?: (
			event: OntarioDateInputCustomEvent<{
				value: string;
				fieldType: 'day' | 'month' | 'year';
			}>,
		) => void;
		/**
		 * Emitted when a keyboard input event occurs when an input has gained focus.
		 */
		onInputOnFocus?: (event: OntarioDateInputCustomEvent<'day' | 'month' | 'year'>) => void;
		/**
		 * Emitted when an `input` event occurs within the component.
		 */
		onInputOnInput?: (
			event: OntarioDateInputCustomEvent<{
				value: string;
				fieldType: 'day' | 'month' | 'year';
			}>,
		) => void;
		/**
		 * An object value used to set the placeholder text for the day, month and year input fields. Any combination of the three input fields (i.e day, month, year) of the date component can be overridden.  This is optional. If no prop is passed, it will not display any placeholder text.
		 */
		placeholder?: DateInputPlaceholder | string;
		/**
		 * A boolean value to determine whether or not the date input is required.  This is optional. If no prop is passed, it will default to `false`.
		 */
		required?: boolean;
	}
	interface OntarioDropdownList {
		/**
		 * The text to display for the dropdown list label.
		 * @example <ontario-dropdown-list   name="ontario-dropdown-list"   caption='{     "captionText": "Label",     "captionType": "heading",   }'   ...> </ontario-dropdown-list>
		 */
		caption?: Caption | string;
		/**
		 * Used to add a custom function to the dropdown onBlur event.
		 */
		customOnBlur?: (event: globalThis.Event) => void;
		/**
		 * Used to add a custom function to the dropdown onChange event.
		 */
		customOnChange?: (event: globalThis.Event) => void;
		/**
		 * Used to add a custom function to the dropdown onFocus event.
		 */
		customOnFocus?: (event: globalThis.Event) => void;
		/**
		 * The ID for the dropdown list. If no ID is provided, one will be generated.
		 */
		elementId?: string;
		/**
		 * Used to include the ontario-hint-expander component for the dropdown list component. This is passed in as an object with key-value pairs.  This is optional.
		 * @example <ontario-dropdown-list   caption='{     "caption": "What province do you live in?",     "captionType": "heading",   }   name="ontario-dropdown-list"   options='[     {       "value": "dropdown-option-1",       "label": "Option 1",       "selected": "true"     },     {       "value": "dropdown-option-2",       "label": "Option 2"     },     {       "value": "dropdown-option-3",       "label": "Option 3"     }   ]'   hint-expander='{    "hint": "Hint expander for the dropdown list",    "content": "Example hint expander content for the dropdown list."   }' > </ontario-dropdown-list>
		 */
		hintExpander?: HintExpander | string;
		/**
		 * Used to include the ontario-hint-text component for the dropdown list. This is optional.
		 */
		hintText?: string | Hint;
		/**
		 * This prop is used to determine whether or not the initial option displayed is empty. If set to `true`, it will render the default “select” text. If set to a string, it will render the string value.
		 * @example <ontario-dropdown-list is-empty-start-option="true"></ontario-dropdown-list>  or  <ontario-dropdown-list is-empty-start-option="Please select"></ontario-dropdown-list>
		 */
		isEmptyStartOption?: boolean | string;
		/**
		 * The language of the component. This is used for translations, and is by default set through event listeners checking for a language property from the header. If no language is passed, it will default to English.
		 */
		language?: Language;
		/**
		 * The name for the dropdown list. The name value is used to reference form data after a form is submitted.
		 */
		name?: string;
		/**
		 * Emitted when a keyboard input event occurs when a dropdown list has lost focus.
		 */
		onDropdownOnBlur?: (event: OntarioDropdownListCustomEvent<InputFocusBlurEvent>) => void;
		/**
		 * Emitted when a keyboard input or mouse event occurs when a dropdown list has been changed.
		 */
		onDropdownOnChange?: (event: OntarioDropdownListCustomEvent<InputInteractionEvent>) => void;
		/**
		 * Emitted when a keyboard input event occurs when a dropdown list has gained focus.
		 */
		onDropdownOnFocus?: (event: OntarioDropdownListCustomEvent<InputFocusBlurEvent>) => void;
		/**
		 * The options for dropdown list.  Each option will be passed in through an object in the options array. This can either be passed in as an object directly (if using react), or as a string in HTML.  In the example below, the options are being passed in as a string and there are three dropdown options displayed.
		 * @example <ontario-dropdown-list   caption='{     "captionText": "Label",     "captionType": "heading",   }'   name="ontario-dropdown-list"   options='[     {       "value": "dropdown-option-1",       "label": "Option 1",       "selected": "true"     },     {       "value": "dropdown-option-2",       "label": "Option 2"     },     {       "value": "dropdown-option-3",       "label": "Option 3"     }   ]' > </ontario-dropdown-list>
		 */
		options?: string | DropdownOption[];
		/**
		 * This is used to determine whether the dropdown list is required or not. This prop also gets passed to the InputCaption utility to display either an optional or required flag in the label. If no prop is set, it will default to false (optional).
		 */
		required?: boolean;
	}
	interface OntarioFieldset {
		/**
		 * The text value used for the legend of the fieldset.
		 */
		legend?: string;
		/**
		 * The size of the fieldset legend. If no prop is passed, it will be `default`.
		 */
		legendSize?: CaptionType;
	}
	interface OntarioFooter {
		/**
		 * The base path to an assets folder containing the Design System assets
		 */
		assetBasePath?: string;
		/**
		 * A prop that stores the required links for all footers. Available options are 'accessibilityLink', 'privacyLink', 'contactLink' and 'printerLink'
		 */
		footerLinks?: FooterLinks | string;
		/**
		 * The language of the component. This is used for translations, and is by default set through event listeners checking for a language property from the header. If no language is passed, it will default to English.
		 */
		language?: Language;
		/**
		 * Social media links to render in the footer. Available options are 'facebook', 'twitter', 'instagram' and 'youtube'
		 */
		socialLinks?: FooterSocialLinksProps | string;
		/**
		 * Stores the titles and content for the expanded three column footer.
		 */
		threeColumnOptions?: ThreeColumnOptions | string;
		/**
		 * Top margin for the footer. By default, this prop is set to `true`, which adds a margin top value of `5rem`. If set to `false`, the top margin value will be set to zero.
		 */
		topMargin?: boolean;
		/**
		 * Stores the titles and content for the expanded two column footer.
		 */
		twoColumnOptions?: TwoColumnOptions | string;
		/**
		 * The type of footer to be rendered. If no prop is provided, it will default to the 'default' type.
		 */
		type?: OntarioFooterType;
	}
	interface OntarioHeader {
		/**
		 * Information pertaining to the application header. This is only necessary for the 'application' header type.  This includes the application name, URL and optional props for the number of links in the subheader for desktop, tablet, and mobile views.
		 * @example  <ontario-header    type="application"    application-header-info='{      "title": "Application name",      "href": "/application-homepage",      "maxSubheaderDesktopLinks": "3",      "maxSubheaderTabletLinks": "2",      "maxSubheaderMobileLinks": "1"    }'>  </ontario-header>
		 */
		applicationHeaderInfo?: ApplicationHeaderInfo | string;
		/**
		 * The base path to an assets folder containing the Design System assets
		 */
		assetBasePath?: string;
		/**
		 * A custom function to pass to the language toggle button.
		 */
		customLanguageToggle?: (event: globalThis.Event) => void;
		/**
		 * Option to disable fetching of the dynamic menu from the Ontario Header API
		 * @example 	<ontario-header 			type="ontario" 			disable-dynamic-menu="false" 		menu-items='[{ 			"title": "Hint", 			"href": "/ontario-hint" 			"linkIsActive": "false" 		},{ 			"title": "Hint", 			"href": "/ontario-hint" 			"linkIsActive": "false" 		},{ 			"title": "Hint", 			"href": "/ontario-hint" 			"linkIsActive": "false" 		},{ 			"title": "Hint", 			"href": "/ontario-hint" 			"linkIsActive": "false" 		}]'> </ontario-header>
		 */
		disableDynamicMenu?: boolean;
		/**
		 * The language of the component. This is used for translations, and is by default set through event listeners checking for a language property from the header. If none is passed, it will default to English.
		 */
		language?: Language;
		/**
		 * Information pertaining to the language toggle links.
		 * @example <ontario-header 	language-toggle-options='{    "englishLink": "/en",    "frenchLink": "/fr"  }'  ... > </ontario-header>
		 */
		languageToggleOptions?: LanguageToggleOptions | string;
		/**
		 * The items that will go inside the menu.
		 */
		menuItems?: MenuItem[] | string;
		/**
		 * The type of header.
		 */
		type?: OntarioHeaderType;
	}
	interface OntarioHintExpander {
		/**
		 * Content to display as the hint, once the expander is toggled open. Please note that any content that is passed into this prop will only be displayed as a string. If you would like to add HTML content, supply child content to the component.
		 * @example <ontario-hint-expander hint="This is the hint"   <img src="https://www.jquery-az.com/html/images/banana.jpg" title="Title of image" alt="alt text here"/>   <p> Here is the content beside the image </p> </ontario-hint-expander>
		 */
		content?: string;
		/**
		 * Used to used to establish a relationship between hint text content and elements using aria-describedby. This is optional - if no ID is passed, one will be generated.
		 */
		elementId?: string;
		/**
		 * Text to display as the hint expander question/statement
		 */
		hint?: string;
		/**
		 * The content type of the hint. If no prop is passed, it will default to a string. If the hint requires multiple lines or HTML, the `hintContentType` prop should be set to `html`.
		 */
		hintContentType?: HintContentType;
		/**
		 * Emitted when a keyboard input or mouse event occurs.
		 */
		onToggleExpanderEvent?: (event: OntarioHintExpanderCustomEvent<MouseEvent | KeyboardEvent>) => void;
	}
	interface OntarioHintText {
		/**
		 * The unique identifier of the element. This is optional - if no ID is passed, one will be generated.
		 */
		elementId?: string;
		/**
		 * Text to display as the hint text statement.  Setting the hint can be done using the host element textContent or through setting this property.  This property will take precedence.
		 * @example <ontario-hint-text hint="Override Hint Text">Hint Text</ontario-button>  The resulting hint text will display `"Override Hint Text"`.
		 */
		hint?: string;
		/**
		 * The content type of the hint. If no prop is passed, it will default to a string. If the hint requires multiple lines or HTML, the `hintContentType` prop should be set to `html`.
		 */
		hintContentType?: HintContentType;
	}
	interface OntarioIconAccessibility {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconAccount {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconAdd {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconAddAlt {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconAlertError {
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconAlertInformation {
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconAlertSuccess {
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconAlertWarning {
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconArrowUp {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconAttach {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconBookmarkOff {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconBookmarkOn {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconCalendar {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconCamera {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconChevronDown {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconChevronLeft {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconChevronRight {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconChevronUp {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconClock {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconClose {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconCloseHeader {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconCloud {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconCollapse {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconCreditCard {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconCriticalAlertWarning {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconDelete {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconDocument {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconDownload {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconDropdownArrow {
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconEdit {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconEmail {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconExpand {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconExport {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconFacebook {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconFacebookAlt {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconFavouriteOff {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconFavouriteOn {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconFilter {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconFlickr {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconGrid {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconHelp {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconInstagram {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconInteracEn {
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconInteracEnAlt {
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconInteracFr {
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconInteracFrAlt {
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconLinkedin {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconLinkedinAlt {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconList {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconLiveChat {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconLocationOff {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconLocationOn {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconLockOff {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconLockOn {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconMap {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconMastercard {
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconMastercardAlt {
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconMediaFastForward {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconMediaFastRewind {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconMediaPause {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconMediaPlay {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconMediaStop {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconMenu {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconMenuHeader {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconMicrophoneOff {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconMicrophoneOn {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconMoreVertical {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconNewWindow {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconNext {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconNotification {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconPasswordHide {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconPasswordShow {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconPhone {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconPhoto {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconPinLocationOff {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconPinLocationOn {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconPrevious {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconPrint {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconRemove {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconRemoveAlt {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconReplay {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconRssFeed {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconSave {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconSearch {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconSearchWhite {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconSentiment1 {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconSentiment2 {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconSentiment3 {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconSentiment4 {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconSentiment5 {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconSettings {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconShare {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconSort {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconTag {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconTextMessage {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconTimer {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconTransportBicycle {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconTransportBus {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconTransportCar {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconTransportWalk {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconTty {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconTwitter {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconTwitterAlt {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconUpload {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconVideo {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconVisa {
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconVoteDislike {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconVoteLike {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconVpnKey {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconWheelchair {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconWifi {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioIconYoutube {
		/**
		 * Set the icon's colour.
		 */
		colour?: IconColour;
		/**
		 * The icon width will autogenerate the height since the icons are in square format, thus preserving the aspect ratio.
		 */
		iconWidth?: IconSize;
	}
	interface OntarioInput {
		/**
		 * The text to display as the input label
		 * @example <ontario-input   caption='{     "captionText": "Address",     "captionType": "heading",   }   required="true"   ...> </ontario-input>
		 */
		caption?: Caption | string;
		/**
		 * Used to add a custom function to the input onBlur event.
		 */
		customOnBlur?: (event: globalThis.Event) => void;
		/**
		 * Used to add a custom function to the input onChange event.
		 */
		customOnChange?: (event: globalThis.Event) => void;
		/**
		 * Used to add a custom function to the input onFocus event.
		 */
		customOnFocus?: (event: globalThis.Event) => void;
		/**
		 * Used to add a custom function to the input onInput event.
		 */
		customOnInput?: (event: globalThis.Event) => void;
		/**
		 * The unique identifier of the input. This is optional - if no ID is passed, one will be generated.
		 */
		elementId?: string;
		/**
		 * Enable live validation on the input.  Custom live validation can be performed using an `inputValidator` validation function.  It will also validate the `required` state if no errors are returned from the `inputValidator`.  Please set a `requiredValidationMessage` to report concisely to the end user what they are required to set.
		 */
		enableLiveValidation?: boolean;
		/**
		 * Set this to display an
		 */
		errorMessage?: string;
		/**
		 * Used to include the ontario-hint-expander component for the input component. This is passed in as an object with key-value pairs.  This is optional.
		 * @example <ontario-input   caption='{     "caption": "Address",     "captionType": "heading",   }   hint-expander='{    "hint": "Hint expander",    "content": "This is the content"   }'   required="true" > </ontario-input>
		 */
		hintExpander?: HintExpander | string;
		/**
		 * Used to include the ontario-hint-text component for the input. This is optional.
		 */
		hintText?: string | Hint;
		/**
		 * Validate the validity of the input value `onBlur`.  This `async` function should return a result to trigger an error message.  Returning `undefined` or `null` will clear it.
		 */
		inputValidator?: (value?: string) => Promise<{ errorMessage?: string } | null | undefined>;
		/**
		 * The width of the input field. If no value is assigned, it will present as the `default` input width.
		 */
		inputWidth?:
			| '2-char-width'
			| '3-char-width'
			| '4-char-width'
			| '5-char-width'
			| '7-char-width'
			| '10-char-width'
			| '20-char-width'
			| 'default';
		/**
		 * The language of the component. This is used for translations, and is by default set through event listeners checking for a language property from the header. If no language is passed, it will default to English.
		 */
		language?: Language;
		/**
		 * The name assigned to the input. The name value is used to reference form data after a form is submitted.
		 */
		name?: string;
		/**
		 * Emitted when an error message is reported to the component.
		 */
		onInputErrorOccurred?: (event: OntarioInputCustomEvent<{ inputId: string; errorMessage: string }>) => void;
		/**
		 * Emitted when a keyboard input event occurs when an input has lost focus.
		 */
		onInputOnBlur?: (event: OntarioInputCustomEvent<InputFocusBlurEvent>) => void;
		/**
		 * Emitted when a keyboard input or mouse event occurs when an input has been changed.
		 */
		onInputOnChange?: (event: OntarioInputCustomEvent<InputInteractionEvent>) => void;
		/**
		 * Emitted when a keyboard input event occurs when an input has gained focus.
		 */
		onInputOnFocus?: (event: OntarioInputCustomEvent<InputFocusBlurEvent>) => void;
		/**
		 * Emitted when a input  occurs when an input has been changed.
		 */
		onInputOnInput?: (event: OntarioInputCustomEvent<InputInputEvent>) => void;
		/**
		 * This is used to determine whether the input is required or not. This prop also gets passed to the InputCaption utility to display either an optional or required flag in the label. If no prop is set, it will default to false (optional).  _Please add a validation messaging using `requiredValidationMessage` if setting this property._
		 * @example <ontario-input 	id="address-line-1" 	caption="Address line 1" 	required 	required-validation-message="Please enter an address, including street number and street name" 	name="address-line-1" 	hint-text="Street and number or P.O. box." ></ontario-input>
		 */
		required?: boolean;
		/**
		 * Custom error message to display if a required field is not filled out.  _Please add a custom message when setting an input as required_.
		 */
		requiredValidationMessage?: string;
		/**
		 * The input type value.  If no `type` is provided, it will default to 'text'.
		 */
		type?: 'text' | 'tel' | 'email' | 'password';
		/**
		 * The input content value.  This is optional.
		 */
		value?: string;
	}
	interface OntarioLanguageToggle {
		/**
		 * A custom function to pass to the language toggle button.  This is optional.
		 */
		customLanguageToggle?: (event: globalThis.Event) => void;
		language?: Language | string;
		/**
		 * An event that emits to other components that the language toggle button has been toggled.
		 */
		onHeaderLanguageToggled?: (event: OntarioLanguageToggleCustomEvent<HeaderLanguageToggleEventDetails>) => void;
		/**
		 * An event to set the Document's HTML lang property, and emit the toggled language to other components.
		 */
		onSetAppLanguage?: (event: OntarioLanguageToggleCustomEvent<string>) => void;
		/**
		 * The size of the language toggle button.  If no prop is passed, it will be set to the `default` size.
		 */
		size?: 'default' | 'small';
		/**
		 * The URL to change to when the language toggle button is clicked.  This is optional.
		 */
		url?: string;
	}
	interface OntarioLoadingIndicator {
		/**
		 * A boolean value to determine whether the loading indicator overlay covers the full page or not. By default, this is set to `true`.  If set to `false`, the loading indicator overlay will be positioned absolutely relative to its container. Note that this will only work if the containing element has a style rule specifying it to be positioned relatively.
		 */
		fullScreenOverlay?: boolean;
		/**
		 * A boolean value to determine whether or not the loading indicator is loading (i.e: is visible) or not.
		 */
		isLoading?: boolean;
		/**
		 * The language of the component. This is used for translations, and is by default set through event listeners checking for a language property from the header. If no language is passed, it will default to English.
		 */
		language?: Language;
		/**
		 * The message that tells the user what is happening or why the user is waiting. If no message prop is passed, it will default to "Loading". Translations for this default message are included.  This is optional.
		 */
		message?: string;
		/**
		 * The type of loading indicator to render.
		 */
		type?: 'small' | 'large';
	}
	interface OntarioPageAlert {
		/**
		 * The main content for the page alert. This can be rendered as either string or HTML content.
		 * @example <ontario-page-alert content="Please look out for an email confirmation with your receipt and order number."> </ontario-page-alert>  or  <ontario-page-alert>  <p>This is a sample page alert component using slots. <a href="#">Learn more</a>.</p> </ontario-page-alert>
		 */
		content?: string;
		/**
		 * The heading for the page alert.
		 * @example <ontario-page-alert heading="Licence plates"> </ontario-page-alert>
		 */
		heading?: string;
		/**
		 * The type of page alert to render. If no value is provided, the `informational` type alert would be rendered.  There are four possible values for page alert: `informational`, `warning`, `success` or `error`.
		 * @example <ontario-page-alert type="error"> </ontario-page-alert>
		 */
		type?: PageAlertType;
	}
	interface OntarioRadioButtons {
		/**
		 * The text to display for the radio button legend.
		 * @example <ontario-radio-buttons   caption='{     "captionText": "Radio legend",     "captionType": "heading",    }'   required="true"   ...> </ontario-radio-buttons>
		 */
		caption?: Caption | string;
		/**
		 * Used to add a custom function to the radio input onBlur event.
		 */
		customOnBlur?: (event: globalThis.Event) => void;
		/**
		 * Used to add a custom function to the radio input onChange event.
		 */
		customOnChange?: (event: globalThis.Event) => void;
		/**
		 * Used to add a custom function to the radio input onFocus event.
		 */
		customOnFocus?: (event: globalThis.Event) => void;
		/**
		 * Used to include the ontario-hint-expander component for the radio button group. This is passed in as an object with key-value pairs.  This is optional.
		 * @example <ontario-radio-buttons   caption='{     "captionText": "Radio legend",     "captionType": "heading",   }' 	 name="radios"   options='[ 	   {        "value": "radio-option-1", 		  "elementId": "radio-1",        "label": "Radio option 1 label",        "hintExpander": { 		  "hint": "Hint expander for radio option 1", 		      "content": "Example hint expander content for radio option 1." 	  }     }   ]'   hint-expander='{     "hint": "Hint expander for the radio button group",     "content": "Example hint expander content for the radio button group."   }'   required="true" > </ontario-radio-buttons>
		 */
		hintExpander?: HintExpander | string;
		/**
		 * Used to include the ontario-hint-text component for radio button group. This is optional.
		 */
		hintText?: string | Hint;
		/**
		 * The language of the component. This is used for translations, and is by default set through event listeners checking for a language property from the header. If no language is passed, it will default to English.
		 */
		language?: Language;
		/**
		 * The name assigned to the radio button. The name value is used to reference form data after a form is submitted.
		 */
		name?: string;
		/**
		 * Emitted when a keyboard input event occurs when a radio option has lost focus.
		 */
		onRadioOnBlur?: (event: OntarioRadioButtonsCustomEvent<InputFocusBlurEvent>) => void;
		/**
		 * Emitted when a keyboard input or mouse event occurs when a radio option has been changed.
		 */
		onRadioOnChange?: (event: OntarioRadioButtonsCustomEvent<RadioAndCheckboxChangeEvent>) => void;
		/**
		 * Emitted when a keyboard input event occurs when a radio option has gained focus.
		 */
		onRadioOnFocus?: (event: OntarioRadioButtonsCustomEvent<InputFocusBlurEvent>) => void;
		/**
		 * The options for the radio button group.  Each property will be passed in through an object in the options array. This can either be passed in as an object directly (if using react), or as a string in HTML. If there are multiple radio buttons in a group, each radio button will be displayed as an option.  In the example below, the options are being passed in as a string and there are two radio buttons to be displayed in the group.
		 * @example <ontario-radio-buttons   caption='{     "captionText": "Radio legend",     "captionType": "heading",   }'   name="radios"   hint-text="Hint text for the radio button group."   options='[     {        "value": "radio-option-1", 		  "elementId": "radio-1",        "label": "Radio option 1 label"     },     {        "value": "radio-option-2", 		  "elementId": "radio-2",        "label": "Radio option 2 label",        "hintExpander": { 		  "hint": "Hint expander for radio option 2", 		      "content": "Example hint expander content for radio option 2." 	  }      }   ]'   required="true" > </ontario-radio-buttons>
		 */
		options?: string | RadioOption[];
		/**
		 * This is used to determine whether the radio button is required or not. This prop also gets passed to the InputCaption utility to display either an optional or required flag in the label. If no prop is set, it will default to false (optional).
		 */
		required?: boolean;
	}
	interface OntarioStepIndicator {
		/**
		 * URL for the back element to set a path for where the link will lead.  If a URL is passed in, the back element will display as an anchor tag. The back element will require either the backButtonURL prop or the customOnClick prop to be passed in order for the back element to display.
		 */
		backButtonUrl?: string;
		/**
		 * A number value to indicate which step the user is currently on.
		 */
		currentStep?: number;
		/**
		 * Used to add a custom function to the back button onClick event.  If this function is passed in, the back element will display as a button. The back element will require either the backButtonURL prop or the customOnClick prop to be passed in order for the back element to display.
		 */
		customOnClick?: (event: globalThis.Event) => void;
		/**
		 * The language of the component. This is used for translations, and is by default set through event listeners checking for a language property from the header. If none are passed, it will default to English.
		 */
		language?: Language;
		/**
		 * A number value to indicate to the user the total number of steps the form has.
		 */
		numberOfSteps?: number;
		/**
		 * A number value to indicate to the user the percentage of the form that has been completed.
		 */
		percentageComplete?: number;
		/**
		 * A boolean value to determine whether or not the back button is displayed for the step indicator.  This is optional. If no prop is passed, it will default to `false`.
		 */
		showBackButton?: boolean;
	}
	interface OntarioTable {
		/**
		 * Specifies the caption (or title) of the table.  This is optional.
		 */
		caption?: string | undefined;
		/**
		 * Used to specify whether or not table data in cells should have reduced top and bottom padding. This is useful for pages with multiple data-heavy tables such as a budget or financial data.  This is optional. By default it will be set to “false”.
		 */
		condensed?: boolean | undefined;
		/**
		 * Used to specify whether or not the table should extend the full width of its container.  This is optional. By default, it will be set to “false”
		 */
		fullWidth?: boolean | undefined;
		/**
		 * Used to define the columns of the table.
		 * @example ; <ontario-table table-columns='[ { "title": "Type of service", "key": "service" }, { "title": "Processing and delivery", "key": "processing" }, { "title": "Cost", "key": "cost", "type": "numeric" } ]' > </ontario-table>
		 */
		tableColumns?: string | TableColumnOptions[];
		/**
		 * Used to define the table body data. Note that the keys passed to the `data` object in the tableData should match the keys of the columns defined in the tableColumns prop.
		 * @example <ontario-table  table-data='[    {      "data": {        "service": "Regular service (online)",        "processing": "15 business days plus delivery by Canada Post",        "cost": "$15"      }    },    {      "data": {        "service": "Premium service (online)",        "cost": "$45",        "processing": "5 business days including delivery by courier"      }    }  ]' > </ontario-table>
		 */
		tableData?: string | TableRowOptions[];
		/**
		 * Indicates whether or not the table data should have alternate row zebra striping.  This is optional. By default, zebra striping will be added when the table rows extend 5 rows. If zebra striping is needed to table rows less than 5 rows, the prop should be set to “enabled”. If no zebra stripes are needed, it should be set to “disabled”.  The default will be set to “auto”.
		 */
		zebraStripes?: 'auto' | 'disabled' | 'enabled' | undefined;
	}
	interface OntarioTextarea {
		/**
		 * The text to display as the textarea label.
		 * @example <ontario-input   caption='{     "captionText": "Address",     "captionType": "heading",   }'   required="true"   ...> </ontario-input>
		 */
		caption?: Caption | string;
		/**
		 * Used to add a custom function to the textarea onBlur event.
		 */
		customOnBlur?: (event: globalThis.Event) => void;
		/**
		 * Used to add a custom function to the textarea onChange event.
		 */
		customOnChange?: (event: globalThis.Event) => void;
		/**
		 * Used to add a custom function to the textarea onFocus event.
		 */
		customOnFocus?: (event: globalThis.Event) => void;
		/**
		 * Used to add a custom function to the textarea onInput event.
		 */
		customOnInput?: (event: globalThis.Event) => void;
		/**
		 * The unique identifier of the textarea. This is optional - if no ID is passed, one will be generated.
		 */
		elementId?: string;
		/**
		 * Used to include the ontario-hint-expander component for the textarea component. This is passed in as an object with key-value pairs.  This is optional.
		 * @example <ontario-textarea   caption='{     "captionText": "What are your thoughts",     "captionType": "heading",   }' 	 name: "textarea"   hint-expander='{     "hint": "This is the hint expander",     "content": "This is the content for the hint expander"   }'   required="true" > </ontario-textarea>
		 */
		hintExpander?: HintExpander | string;
		/**
		 * Used to include the ontario-hint-text component for the textarea. This is optional.
		 */
		hintText?: string | Hint;
		/**
		 * The language of the component. This is used for translations, and is by default set through event listeners checking for a language property from the header. If no language is passed, it will default to English.
		 */
		language?: Language;
		/**
		 * The name assigned to the textarea. The name value is used to reference form data after a form is submitted.
		 */
		name?: string;
		/**
		 * Emitted when a keyboard input event occurs when an input has lost focus.
		 */
		onInputOnBlur?: (event: OntarioTextareaCustomEvent<InputFocusBlurEvent>) => void;
		/**
		 * Emitted when a keyboard input or mouse event occurs when an input has been changed.
		 */
		onInputOnChange?: (event: OntarioTextareaCustomEvent<InputInteractionEvent>) => void;
		/**
		 * Emitted when a keyboard input event occurs when an input has gained focus.
		 */
		onInputOnFocus?: (event: OntarioTextareaCustomEvent<InputFocusBlurEvent>) => void;
		/**
		 * Emitted when a input event occurs when an input has been changed.
		 */
		onInputOnInput?: (event: OntarioTextareaCustomEvent<InputInputEvent>) => void;
		/**
		 * This is used to determine whether the textarea is required or not. This prop also gets passed to the InputCaption utility to display either an optional or required flag in the label. If no prop is set, it will default to false (optional).
		 */
		required?: boolean;
		/**
		 * The textarea content value.
		 */
		value?: string;
	}
	interface IntrinsicElements {
		'ontario-accordion': OntarioAccordion;
		'ontario-aside': OntarioAside;
		'ontario-back-to-top': OntarioBackToTop;
		'ontario-blockquote': OntarioBlockquote;
		'ontario-button': OntarioButton;
		'ontario-callout': OntarioCallout;
		'ontario-card': OntarioCard;
		'ontario-card-collection': OntarioCardCollection;
		'ontario-checkboxes': OntarioCheckboxes;
		'ontario-critical-alert': OntarioCriticalAlert;
		'ontario-date-input': OntarioDateInput;
		'ontario-dropdown-list': OntarioDropdownList;
		'ontario-fieldset': OntarioFieldset;
		'ontario-footer': OntarioFooter;
		'ontario-header': OntarioHeader;
		'ontario-hint-expander': OntarioHintExpander;
		'ontario-hint-text': OntarioHintText;
		'ontario-icon-accessibility': OntarioIconAccessibility;
		'ontario-icon-account': OntarioIconAccount;
		'ontario-icon-add': OntarioIconAdd;
		'ontario-icon-add-alt': OntarioIconAddAlt;
		'ontario-icon-alert-error': OntarioIconAlertError;
		'ontario-icon-alert-information': OntarioIconAlertInformation;
		'ontario-icon-alert-success': OntarioIconAlertSuccess;
		'ontario-icon-alert-warning': OntarioIconAlertWarning;
		'ontario-icon-arrow-up': OntarioIconArrowUp;
		'ontario-icon-attach': OntarioIconAttach;
		'ontario-icon-bookmark-off': OntarioIconBookmarkOff;
		'ontario-icon-bookmark-on': OntarioIconBookmarkOn;
		'ontario-icon-calendar': OntarioIconCalendar;
		'ontario-icon-camera': OntarioIconCamera;
		'ontario-icon-chevron-down': OntarioIconChevronDown;
		'ontario-icon-chevron-left': OntarioIconChevronLeft;
		'ontario-icon-chevron-right': OntarioIconChevronRight;
		'ontario-icon-chevron-up': OntarioIconChevronUp;
		'ontario-icon-clock': OntarioIconClock;
		'ontario-icon-close': OntarioIconClose;
		'ontario-icon-close-header': OntarioIconCloseHeader;
		'ontario-icon-cloud': OntarioIconCloud;
		'ontario-icon-collapse': OntarioIconCollapse;
		'ontario-icon-credit-card': OntarioIconCreditCard;
		'ontario-icon-critical-alert-warning': OntarioIconCriticalAlertWarning;
		'ontario-icon-delete': OntarioIconDelete;
		'ontario-icon-document': OntarioIconDocument;
		'ontario-icon-download': OntarioIconDownload;
		'ontario-icon-dropdown-arrow': OntarioIconDropdownArrow;
		'ontario-icon-edit': OntarioIconEdit;
		'ontario-icon-email': OntarioIconEmail;
		'ontario-icon-expand': OntarioIconExpand;
		'ontario-icon-export': OntarioIconExport;
		'ontario-icon-facebook': OntarioIconFacebook;
		'ontario-icon-facebook-alt': OntarioIconFacebookAlt;
		'ontario-icon-favourite-off': OntarioIconFavouriteOff;
		'ontario-icon-favourite-on': OntarioIconFavouriteOn;
		'ontario-icon-filter': OntarioIconFilter;
		'ontario-icon-flickr': OntarioIconFlickr;
		'ontario-icon-grid': OntarioIconGrid;
		'ontario-icon-help': OntarioIconHelp;
		'ontario-icon-instagram': OntarioIconInstagram;
		'ontario-icon-interac-en': OntarioIconInteracEn;
		'ontario-icon-interac-en-alt': OntarioIconInteracEnAlt;
		'ontario-icon-interac-fr': OntarioIconInteracFr;
		'ontario-icon-interac-fr-alt': OntarioIconInteracFrAlt;
		'ontario-icon-linkedin': OntarioIconLinkedin;
		'ontario-icon-linkedin-alt': OntarioIconLinkedinAlt;
		'ontario-icon-list': OntarioIconList;
		'ontario-icon-live-chat': OntarioIconLiveChat;
		'ontario-icon-location-off': OntarioIconLocationOff;
		'ontario-icon-location-on': OntarioIconLocationOn;
		'ontario-icon-lock-off': OntarioIconLockOff;
		'ontario-icon-lock-on': OntarioIconLockOn;
		'ontario-icon-map': OntarioIconMap;
		'ontario-icon-mastercard': OntarioIconMastercard;
		'ontario-icon-mastercard-alt': OntarioIconMastercardAlt;
		'ontario-icon-media-fast-forward': OntarioIconMediaFastForward;
		'ontario-icon-media-fast-rewind': OntarioIconMediaFastRewind;
		'ontario-icon-media-pause': OntarioIconMediaPause;
		'ontario-icon-media-play': OntarioIconMediaPlay;
		'ontario-icon-media-stop': OntarioIconMediaStop;
		'ontario-icon-menu': OntarioIconMenu;
		'ontario-icon-menu-header': OntarioIconMenuHeader;
		'ontario-icon-microphone-off': OntarioIconMicrophoneOff;
		'ontario-icon-microphone-on': OntarioIconMicrophoneOn;
		'ontario-icon-more-vertical': OntarioIconMoreVertical;
		'ontario-icon-new-window': OntarioIconNewWindow;
		'ontario-icon-next': OntarioIconNext;
		'ontario-icon-notification': OntarioIconNotification;
		'ontario-icon-password-hide': OntarioIconPasswordHide;
		'ontario-icon-password-show': OntarioIconPasswordShow;
		'ontario-icon-phone': OntarioIconPhone;
		'ontario-icon-photo': OntarioIconPhoto;
		'ontario-icon-pin-location-off': OntarioIconPinLocationOff;
		'ontario-icon-pin-location-on': OntarioIconPinLocationOn;
		'ontario-icon-previous': OntarioIconPrevious;
		'ontario-icon-print': OntarioIconPrint;
		'ontario-icon-remove': OntarioIconRemove;
		'ontario-icon-remove-alt': OntarioIconRemoveAlt;
		'ontario-icon-replay': OntarioIconReplay;
		'ontario-icon-rss-feed': OntarioIconRssFeed;
		'ontario-icon-save': OntarioIconSave;
		'ontario-icon-search': OntarioIconSearch;
		'ontario-icon-search-white': OntarioIconSearchWhite;
		'ontario-icon-sentiment-1': OntarioIconSentiment1;
		'ontario-icon-sentiment-2': OntarioIconSentiment2;
		'ontario-icon-sentiment-3': OntarioIconSentiment3;
		'ontario-icon-sentiment-4': OntarioIconSentiment4;
		'ontario-icon-sentiment-5': OntarioIconSentiment5;
		'ontario-icon-settings': OntarioIconSettings;
		'ontario-icon-share': OntarioIconShare;
		'ontario-icon-sort': OntarioIconSort;
		'ontario-icon-tag': OntarioIconTag;
		'ontario-icon-text-message': OntarioIconTextMessage;
		'ontario-icon-timer': OntarioIconTimer;
		'ontario-icon-transport-bicycle': OntarioIconTransportBicycle;
		'ontario-icon-transport-bus': OntarioIconTransportBus;
		'ontario-icon-transport-car': OntarioIconTransportCar;
		'ontario-icon-transport-walk': OntarioIconTransportWalk;
		'ontario-icon-tty': OntarioIconTty;
		'ontario-icon-twitter': OntarioIconTwitter;
		'ontario-icon-twitter-alt': OntarioIconTwitterAlt;
		'ontario-icon-upload': OntarioIconUpload;
		'ontario-icon-video': OntarioIconVideo;
		'ontario-icon-visa': OntarioIconVisa;
		'ontario-icon-vote-dislike': OntarioIconVoteDislike;
		'ontario-icon-vote-like': OntarioIconVoteLike;
		'ontario-icon-vpn-key': OntarioIconVpnKey;
		'ontario-icon-wheelchair': OntarioIconWheelchair;
		'ontario-icon-wifi': OntarioIconWifi;
		'ontario-icon-youtube': OntarioIconYoutube;
		'ontario-input': OntarioInput;
		'ontario-language-toggle': OntarioLanguageToggle;
		'ontario-loading-indicator': OntarioLoadingIndicator;
		'ontario-page-alert': OntarioPageAlert;
		'ontario-radio-buttons': OntarioRadioButtons;
		'ontario-step-indicator': OntarioStepIndicator;
		'ontario-table': OntarioTable;
		'ontario-textarea': OntarioTextarea;
	}
}
export { LocalJSX as JSX };
declare module '@stencil/core' {
	export namespace JSX {
		interface IntrinsicElements {
			'ontario-accordion': LocalJSX.OntarioAccordion & JSXBase.HTMLAttributes<HTMLOntarioAccordionElement>;
			'ontario-aside': LocalJSX.OntarioAside & JSXBase.HTMLAttributes<HTMLOntarioAsideElement>;
			'ontario-back-to-top': LocalJSX.OntarioBackToTop & JSXBase.HTMLAttributes<HTMLOntarioBackToTopElement>;
			'ontario-blockquote': LocalJSX.OntarioBlockquote & JSXBase.HTMLAttributes<HTMLOntarioBlockquoteElement>;
			'ontario-button': LocalJSX.OntarioButton & JSXBase.HTMLAttributes<HTMLOntarioButtonElement>;
			'ontario-callout': LocalJSX.OntarioCallout & JSXBase.HTMLAttributes<HTMLOntarioCalloutElement>;
			'ontario-card': LocalJSX.OntarioCard & JSXBase.HTMLAttributes<HTMLOntarioCardElement>;
			'ontario-card-collection': LocalJSX.OntarioCardCollection &
				JSXBase.HTMLAttributes<HTMLOntarioCardCollectionElement>;
			'ontario-checkboxes': LocalJSX.OntarioCheckboxes & JSXBase.HTMLAttributes<HTMLOntarioCheckboxesElement>;
			'ontario-critical-alert': LocalJSX.OntarioCriticalAlert & JSXBase.HTMLAttributes<HTMLOntarioCriticalAlertElement>;
			'ontario-date-input': LocalJSX.OntarioDateInput & JSXBase.HTMLAttributes<HTMLOntarioDateInputElement>;
			'ontario-dropdown-list': LocalJSX.OntarioDropdownList & JSXBase.HTMLAttributes<HTMLOntarioDropdownListElement>;
			'ontario-fieldset': LocalJSX.OntarioFieldset & JSXBase.HTMLAttributes<HTMLOntarioFieldsetElement>;
			'ontario-footer': LocalJSX.OntarioFooter & JSXBase.HTMLAttributes<HTMLOntarioFooterElement>;
			'ontario-header': LocalJSX.OntarioHeader & JSXBase.HTMLAttributes<HTMLOntarioHeaderElement>;
			'ontario-hint-expander': LocalJSX.OntarioHintExpander & JSXBase.HTMLAttributes<HTMLOntarioHintExpanderElement>;
			'ontario-hint-text': LocalJSX.OntarioHintText & JSXBase.HTMLAttributes<HTMLOntarioHintTextElement>;
			'ontario-icon-accessibility': LocalJSX.OntarioIconAccessibility &
				JSXBase.HTMLAttributes<HTMLOntarioIconAccessibilityElement>;
			'ontario-icon-account': LocalJSX.OntarioIconAccount & JSXBase.HTMLAttributes<HTMLOntarioIconAccountElement>;
			'ontario-icon-add': LocalJSX.OntarioIconAdd & JSXBase.HTMLAttributes<HTMLOntarioIconAddElement>;
			'ontario-icon-add-alt': LocalJSX.OntarioIconAddAlt & JSXBase.HTMLAttributes<HTMLOntarioIconAddAltElement>;
			'ontario-icon-alert-error': LocalJSX.OntarioIconAlertError &
				JSXBase.HTMLAttributes<HTMLOntarioIconAlertErrorElement>;
			'ontario-icon-alert-information': LocalJSX.OntarioIconAlertInformation &
				JSXBase.HTMLAttributes<HTMLOntarioIconAlertInformationElement>;
			'ontario-icon-alert-success': LocalJSX.OntarioIconAlertSuccess &
				JSXBase.HTMLAttributes<HTMLOntarioIconAlertSuccessElement>;
			'ontario-icon-alert-warning': LocalJSX.OntarioIconAlertWarning &
				JSXBase.HTMLAttributes<HTMLOntarioIconAlertWarningElement>;
			'ontario-icon-arrow-up': LocalJSX.OntarioIconArrowUp & JSXBase.HTMLAttributes<HTMLOntarioIconArrowUpElement>;
			'ontario-icon-attach': LocalJSX.OntarioIconAttach & JSXBase.HTMLAttributes<HTMLOntarioIconAttachElement>;
			'ontario-icon-bookmark-off': LocalJSX.OntarioIconBookmarkOff &
				JSXBase.HTMLAttributes<HTMLOntarioIconBookmarkOffElement>;
			'ontario-icon-bookmark-on': LocalJSX.OntarioIconBookmarkOn &
				JSXBase.HTMLAttributes<HTMLOntarioIconBookmarkOnElement>;
			'ontario-icon-calendar': LocalJSX.OntarioIconCalendar & JSXBase.HTMLAttributes<HTMLOntarioIconCalendarElement>;
			'ontario-icon-camera': LocalJSX.OntarioIconCamera & JSXBase.HTMLAttributes<HTMLOntarioIconCameraElement>;
			'ontario-icon-chevron-down': LocalJSX.OntarioIconChevronDown &
				JSXBase.HTMLAttributes<HTMLOntarioIconChevronDownElement>;
			'ontario-icon-chevron-left': LocalJSX.OntarioIconChevronLeft &
				JSXBase.HTMLAttributes<HTMLOntarioIconChevronLeftElement>;
			'ontario-icon-chevron-right': LocalJSX.OntarioIconChevronRight &
				JSXBase.HTMLAttributes<HTMLOntarioIconChevronRightElement>;
			'ontario-icon-chevron-up': LocalJSX.OntarioIconChevronUp &
				JSXBase.HTMLAttributes<HTMLOntarioIconChevronUpElement>;
			'ontario-icon-clock': LocalJSX.OntarioIconClock & JSXBase.HTMLAttributes<HTMLOntarioIconClockElement>;
			'ontario-icon-close': LocalJSX.OntarioIconClose & JSXBase.HTMLAttributes<HTMLOntarioIconCloseElement>;
			'ontario-icon-close-header': LocalJSX.OntarioIconCloseHeader &
				JSXBase.HTMLAttributes<HTMLOntarioIconCloseHeaderElement>;
			'ontario-icon-cloud': LocalJSX.OntarioIconCloud & JSXBase.HTMLAttributes<HTMLOntarioIconCloudElement>;
			'ontario-icon-collapse': LocalJSX.OntarioIconCollapse & JSXBase.HTMLAttributes<HTMLOntarioIconCollapseElement>;
			'ontario-icon-credit-card': LocalJSX.OntarioIconCreditCard &
				JSXBase.HTMLAttributes<HTMLOntarioIconCreditCardElement>;
			'ontario-icon-critical-alert-warning': LocalJSX.OntarioIconCriticalAlertWarning &
				JSXBase.HTMLAttributes<HTMLOntarioIconCriticalAlertWarningElement>;
			'ontario-icon-delete': LocalJSX.OntarioIconDelete & JSXBase.HTMLAttributes<HTMLOntarioIconDeleteElement>;
			'ontario-icon-document': LocalJSX.OntarioIconDocument & JSXBase.HTMLAttributes<HTMLOntarioIconDocumentElement>;
			'ontario-icon-download': LocalJSX.OntarioIconDownload & JSXBase.HTMLAttributes<HTMLOntarioIconDownloadElement>;
			'ontario-icon-dropdown-arrow': LocalJSX.OntarioIconDropdownArrow &
				JSXBase.HTMLAttributes<HTMLOntarioIconDropdownArrowElement>;
			'ontario-icon-edit': LocalJSX.OntarioIconEdit & JSXBase.HTMLAttributes<HTMLOntarioIconEditElement>;
			'ontario-icon-email': LocalJSX.OntarioIconEmail & JSXBase.HTMLAttributes<HTMLOntarioIconEmailElement>;
			'ontario-icon-expand': LocalJSX.OntarioIconExpand & JSXBase.HTMLAttributes<HTMLOntarioIconExpandElement>;
			'ontario-icon-export': LocalJSX.OntarioIconExport & JSXBase.HTMLAttributes<HTMLOntarioIconExportElement>;
			'ontario-icon-facebook': LocalJSX.OntarioIconFacebook & JSXBase.HTMLAttributes<HTMLOntarioIconFacebookElement>;
			'ontario-icon-facebook-alt': LocalJSX.OntarioIconFacebookAlt &
				JSXBase.HTMLAttributes<HTMLOntarioIconFacebookAltElement>;
			'ontario-icon-favourite-off': LocalJSX.OntarioIconFavouriteOff &
				JSXBase.HTMLAttributes<HTMLOntarioIconFavouriteOffElement>;
			'ontario-icon-favourite-on': LocalJSX.OntarioIconFavouriteOn &
				JSXBase.HTMLAttributes<HTMLOntarioIconFavouriteOnElement>;
			'ontario-icon-filter': LocalJSX.OntarioIconFilter & JSXBase.HTMLAttributes<HTMLOntarioIconFilterElement>;
			'ontario-icon-flickr': LocalJSX.OntarioIconFlickr & JSXBase.HTMLAttributes<HTMLOntarioIconFlickrElement>;
			'ontario-icon-grid': LocalJSX.OntarioIconGrid & JSXBase.HTMLAttributes<HTMLOntarioIconGridElement>;
			'ontario-icon-help': LocalJSX.OntarioIconHelp & JSXBase.HTMLAttributes<HTMLOntarioIconHelpElement>;
			'ontario-icon-instagram': LocalJSX.OntarioIconInstagram & JSXBase.HTMLAttributes<HTMLOntarioIconInstagramElement>;
			'ontario-icon-interac-en': LocalJSX.OntarioIconInteracEn &
				JSXBase.HTMLAttributes<HTMLOntarioIconInteracEnElement>;
			'ontario-icon-interac-en-alt': LocalJSX.OntarioIconInteracEnAlt &
				JSXBase.HTMLAttributes<HTMLOntarioIconInteracEnAltElement>;
			'ontario-icon-interac-fr': LocalJSX.OntarioIconInteracFr &
				JSXBase.HTMLAttributes<HTMLOntarioIconInteracFrElement>;
			'ontario-icon-interac-fr-alt': LocalJSX.OntarioIconInteracFrAlt &
				JSXBase.HTMLAttributes<HTMLOntarioIconInteracFrAltElement>;
			'ontario-icon-linkedin': LocalJSX.OntarioIconLinkedin & JSXBase.HTMLAttributes<HTMLOntarioIconLinkedinElement>;
			'ontario-icon-linkedin-alt': LocalJSX.OntarioIconLinkedinAlt &
				JSXBase.HTMLAttributes<HTMLOntarioIconLinkedinAltElement>;
			'ontario-icon-list': LocalJSX.OntarioIconList & JSXBase.HTMLAttributes<HTMLOntarioIconListElement>;
			'ontario-icon-live-chat': LocalJSX.OntarioIconLiveChat & JSXBase.HTMLAttributes<HTMLOntarioIconLiveChatElement>;
			'ontario-icon-location-off': LocalJSX.OntarioIconLocationOff &
				JSXBase.HTMLAttributes<HTMLOntarioIconLocationOffElement>;
			'ontario-icon-location-on': LocalJSX.OntarioIconLocationOn &
				JSXBase.HTMLAttributes<HTMLOntarioIconLocationOnElement>;
			'ontario-icon-lock-off': LocalJSX.OntarioIconLockOff & JSXBase.HTMLAttributes<HTMLOntarioIconLockOffElement>;
			'ontario-icon-lock-on': LocalJSX.OntarioIconLockOn & JSXBase.HTMLAttributes<HTMLOntarioIconLockOnElement>;
			'ontario-icon-map': LocalJSX.OntarioIconMap & JSXBase.HTMLAttributes<HTMLOntarioIconMapElement>;
			'ontario-icon-mastercard': LocalJSX.OntarioIconMastercard &
				JSXBase.HTMLAttributes<HTMLOntarioIconMastercardElement>;
			'ontario-icon-mastercard-alt': LocalJSX.OntarioIconMastercardAlt &
				JSXBase.HTMLAttributes<HTMLOntarioIconMastercardAltElement>;
			'ontario-icon-media-fast-forward': LocalJSX.OntarioIconMediaFastForward &
				JSXBase.HTMLAttributes<HTMLOntarioIconMediaFastForwardElement>;
			'ontario-icon-media-fast-rewind': LocalJSX.OntarioIconMediaFastRewind &
				JSXBase.HTMLAttributes<HTMLOntarioIconMediaFastRewindElement>;
			'ontario-icon-media-pause': LocalJSX.OntarioIconMediaPause &
				JSXBase.HTMLAttributes<HTMLOntarioIconMediaPauseElement>;
			'ontario-icon-media-play': LocalJSX.OntarioIconMediaPlay &
				JSXBase.HTMLAttributes<HTMLOntarioIconMediaPlayElement>;
			'ontario-icon-media-stop': LocalJSX.OntarioIconMediaStop &
				JSXBase.HTMLAttributes<HTMLOntarioIconMediaStopElement>;
			'ontario-icon-menu': LocalJSX.OntarioIconMenu & JSXBase.HTMLAttributes<HTMLOntarioIconMenuElement>;
			'ontario-icon-menu-header': LocalJSX.OntarioIconMenuHeader &
				JSXBase.HTMLAttributes<HTMLOntarioIconMenuHeaderElement>;
			'ontario-icon-microphone-off': LocalJSX.OntarioIconMicrophoneOff &
				JSXBase.HTMLAttributes<HTMLOntarioIconMicrophoneOffElement>;
			'ontario-icon-microphone-on': LocalJSX.OntarioIconMicrophoneOn &
				JSXBase.HTMLAttributes<HTMLOntarioIconMicrophoneOnElement>;
			'ontario-icon-more-vertical': LocalJSX.OntarioIconMoreVertical &
				JSXBase.HTMLAttributes<HTMLOntarioIconMoreVerticalElement>;
			'ontario-icon-new-window': LocalJSX.OntarioIconNewWindow &
				JSXBase.HTMLAttributes<HTMLOntarioIconNewWindowElement>;
			'ontario-icon-next': LocalJSX.OntarioIconNext & JSXBase.HTMLAttributes<HTMLOntarioIconNextElement>;
			'ontario-icon-notification': LocalJSX.OntarioIconNotification &
				JSXBase.HTMLAttributes<HTMLOntarioIconNotificationElement>;
			'ontario-icon-password-hide': LocalJSX.OntarioIconPasswordHide &
				JSXBase.HTMLAttributes<HTMLOntarioIconPasswordHideElement>;
			'ontario-icon-password-show': LocalJSX.OntarioIconPasswordShow &
				JSXBase.HTMLAttributes<HTMLOntarioIconPasswordShowElement>;
			'ontario-icon-phone': LocalJSX.OntarioIconPhone & JSXBase.HTMLAttributes<HTMLOntarioIconPhoneElement>;
			'ontario-icon-photo': LocalJSX.OntarioIconPhoto & JSXBase.HTMLAttributes<HTMLOntarioIconPhotoElement>;
			'ontario-icon-pin-location-off': LocalJSX.OntarioIconPinLocationOff &
				JSXBase.HTMLAttributes<HTMLOntarioIconPinLocationOffElement>;
			'ontario-icon-pin-location-on': LocalJSX.OntarioIconPinLocationOn &
				JSXBase.HTMLAttributes<HTMLOntarioIconPinLocationOnElement>;
			'ontario-icon-previous': LocalJSX.OntarioIconPrevious & JSXBase.HTMLAttributes<HTMLOntarioIconPreviousElement>;
			'ontario-icon-print': LocalJSX.OntarioIconPrint & JSXBase.HTMLAttributes<HTMLOntarioIconPrintElement>;
			'ontario-icon-remove': LocalJSX.OntarioIconRemove & JSXBase.HTMLAttributes<HTMLOntarioIconRemoveElement>;
			'ontario-icon-remove-alt': LocalJSX.OntarioIconRemoveAlt &
				JSXBase.HTMLAttributes<HTMLOntarioIconRemoveAltElement>;
			'ontario-icon-replay': LocalJSX.OntarioIconReplay & JSXBase.HTMLAttributes<HTMLOntarioIconReplayElement>;
			'ontario-icon-rss-feed': LocalJSX.OntarioIconRssFeed & JSXBase.HTMLAttributes<HTMLOntarioIconRssFeedElement>;
			'ontario-icon-save': LocalJSX.OntarioIconSave & JSXBase.HTMLAttributes<HTMLOntarioIconSaveElement>;
			'ontario-icon-search': LocalJSX.OntarioIconSearch & JSXBase.HTMLAttributes<HTMLOntarioIconSearchElement>;
			'ontario-icon-search-white': LocalJSX.OntarioIconSearchWhite &
				JSXBase.HTMLAttributes<HTMLOntarioIconSearchWhiteElement>;
			'ontario-icon-sentiment-1': LocalJSX.OntarioIconSentiment1 &
				JSXBase.HTMLAttributes<HTMLOntarioIconSentiment1Element>;
			'ontario-icon-sentiment-2': LocalJSX.OntarioIconSentiment2 &
				JSXBase.HTMLAttributes<HTMLOntarioIconSentiment2Element>;
			'ontario-icon-sentiment-3': LocalJSX.OntarioIconSentiment3 &
				JSXBase.HTMLAttributes<HTMLOntarioIconSentiment3Element>;
			'ontario-icon-sentiment-4': LocalJSX.OntarioIconSentiment4 &
				JSXBase.HTMLAttributes<HTMLOntarioIconSentiment4Element>;
			'ontario-icon-sentiment-5': LocalJSX.OntarioIconSentiment5 &
				JSXBase.HTMLAttributes<HTMLOntarioIconSentiment5Element>;
			'ontario-icon-settings': LocalJSX.OntarioIconSettings & JSXBase.HTMLAttributes<HTMLOntarioIconSettingsElement>;
			'ontario-icon-share': LocalJSX.OntarioIconShare & JSXBase.HTMLAttributes<HTMLOntarioIconShareElement>;
			'ontario-icon-sort': LocalJSX.OntarioIconSort & JSXBase.HTMLAttributes<HTMLOntarioIconSortElement>;
			'ontario-icon-tag': LocalJSX.OntarioIconTag & JSXBase.HTMLAttributes<HTMLOntarioIconTagElement>;
			'ontario-icon-text-message': LocalJSX.OntarioIconTextMessage &
				JSXBase.HTMLAttributes<HTMLOntarioIconTextMessageElement>;
			'ontario-icon-timer': LocalJSX.OntarioIconTimer & JSXBase.HTMLAttributes<HTMLOntarioIconTimerElement>;
			'ontario-icon-transport-bicycle': LocalJSX.OntarioIconTransportBicycle &
				JSXBase.HTMLAttributes<HTMLOntarioIconTransportBicycleElement>;
			'ontario-icon-transport-bus': LocalJSX.OntarioIconTransportBus &
				JSXBase.HTMLAttributes<HTMLOntarioIconTransportBusElement>;
			'ontario-icon-transport-car': LocalJSX.OntarioIconTransportCar &
				JSXBase.HTMLAttributes<HTMLOntarioIconTransportCarElement>;
			'ontario-icon-transport-walk': LocalJSX.OntarioIconTransportWalk &
				JSXBase.HTMLAttributes<HTMLOntarioIconTransportWalkElement>;
			'ontario-icon-tty': LocalJSX.OntarioIconTty & JSXBase.HTMLAttributes<HTMLOntarioIconTtyElement>;
			'ontario-icon-twitter': LocalJSX.OntarioIconTwitter & JSXBase.HTMLAttributes<HTMLOntarioIconTwitterElement>;
			'ontario-icon-twitter-alt': LocalJSX.OntarioIconTwitterAlt &
				JSXBase.HTMLAttributes<HTMLOntarioIconTwitterAltElement>;
			'ontario-icon-upload': LocalJSX.OntarioIconUpload & JSXBase.HTMLAttributes<HTMLOntarioIconUploadElement>;
			'ontario-icon-video': LocalJSX.OntarioIconVideo & JSXBase.HTMLAttributes<HTMLOntarioIconVideoElement>;
			'ontario-icon-visa': LocalJSX.OntarioIconVisa & JSXBase.HTMLAttributes<HTMLOntarioIconVisaElement>;
			'ontario-icon-vote-dislike': LocalJSX.OntarioIconVoteDislike &
				JSXBase.HTMLAttributes<HTMLOntarioIconVoteDislikeElement>;
			'ontario-icon-vote-like': LocalJSX.OntarioIconVoteLike & JSXBase.HTMLAttributes<HTMLOntarioIconVoteLikeElement>;
			'ontario-icon-vpn-key': LocalJSX.OntarioIconVpnKey & JSXBase.HTMLAttributes<HTMLOntarioIconVpnKeyElement>;
			'ontario-icon-wheelchair': LocalJSX.OntarioIconWheelchair &
				JSXBase.HTMLAttributes<HTMLOntarioIconWheelchairElement>;
			'ontario-icon-wifi': LocalJSX.OntarioIconWifi & JSXBase.HTMLAttributes<HTMLOntarioIconWifiElement>;
			'ontario-icon-youtube': LocalJSX.OntarioIconYoutube & JSXBase.HTMLAttributes<HTMLOntarioIconYoutubeElement>;
			'ontario-input': LocalJSX.OntarioInput & JSXBase.HTMLAttributes<HTMLOntarioInputElement>;
			'ontario-language-toggle': LocalJSX.OntarioLanguageToggle &
				JSXBase.HTMLAttributes<HTMLOntarioLanguageToggleElement>;
			'ontario-loading-indicator': LocalJSX.OntarioLoadingIndicator &
				JSXBase.HTMLAttributes<HTMLOntarioLoadingIndicatorElement>;
			'ontario-page-alert': LocalJSX.OntarioPageAlert & JSXBase.HTMLAttributes<HTMLOntarioPageAlertElement>;
			'ontario-radio-buttons': LocalJSX.OntarioRadioButtons & JSXBase.HTMLAttributes<HTMLOntarioRadioButtonsElement>;
			'ontario-step-indicator': LocalJSX.OntarioStepIndicator & JSXBase.HTMLAttributes<HTMLOntarioStepIndicatorElement>;
			'ontario-table': LocalJSX.OntarioTable & JSXBase.HTMLAttributes<HTMLOntarioTableElement>;
			'ontario-textarea': LocalJSX.OntarioTextarea & JSXBase.HTMLAttributes<HTMLOntarioTextareaElement>;
		}
	}
}
